# 1> UNIX의 기초
## 1. 로그인/로그아웃
UNIX는 '멀티 사용자 시스템'이기 때문에 복수의 사용자가 존재 가능하다. 때문에 리눅스에서는 인증과정인 로그인을 하지않으면 시스템을 사용할 수 없다. 시스템 사용을 끝내려면 로그아웃하면 된다.
> 로그 : 특정 사용자의 시스템 이용 이력
> 세션 : 로그인한 후부터 로그아웃할 때까지, 접속중인 사용자로 보면된다.

## 2. 셀과 커맨드
* 셸(shell) : 사용자가 입력한 지시에 따라 커맨드(명령)을 실행하고 그 결과를 출력하는 프로그램
```shell
AAA@bbb:~$
```
* 커맨드 : 시스템을 처리하는 명령

셸은 커맨드명을 읽어서 셸의 함수, 내장 커맨드, 환경 변수 경로에 포함된 디렉터리에서 같은 커맨드를 찾아 인수를 해당 커맨드에 넘겨서 실행한다. 또한 커맨드는 내부에서 OS의 커널을 이용하며 이때 셸은 사용자와 커널을 잇는 역할을 하게 된다.
```shell
$ ls -al
```
이때, ls는 커맨드, -al은 인수의 역할을 한다. 커맨드에 따라서 함께 쓸 수 없는 조합, 지정 순서가 정해져 있는 것 등이 있으니 주의하도록 한다.

## 3. 매뉴얼 커맨드 man
man 커맨드는 각 커맨드의 사용법, 동작을 사용자가 확인할 수 있는 메뉴얼 참조 커맨드다.

#### 1. man 페이지 조작 방법
페이지 내 이동에는 지정된 환경 변수 MANPAGER에 설정된 pager 커맨드를 사용한다.
예를 들어, less(1), lv(1)가 MANPAGER로 쓰이는 경우의 조작법은 다음과 같다.

| 조작 | 키 |
|:--------:|:--------:|
| 한 줄 위로 이동 | k |
| 한 줄 아래로 이동 | j |
| 한 페이지 아래로 이동(다음 페이지) | 스페이스 바 |
| 페이지 첫머리로 이동 | g |
| 페이지 끝으로 이동 | G |
| 아래로 검색 | /(검색문자) |
| 다음 검색 결과(순방향) | n |
| 위로 검색 | ?(검색 문자) |
| 이전 검색 결과(역방향) | N |

#### 2. man 읽는 법
커맨드에 따라서는 man파일에만 정보가 있을 때도 있으니, 읽는 법을 꼭 알아두어야 한다.

| 섹션 | 영어 | 설명 |
|:--------:|:--------:|:--------:|
| 이름 | NAME | 커맨드명과 간단한 설명 |
| 서식 | SYNOPSIS | 커맨드와 옵션 기술 방법 |
| 설명 | DESCRIPTION | 커맨드에 대한 상세 설명 |
| 옵션 | OPTION | 커맨드의 옵션 설명 |
| 파일 | FILES | 커맨드 관련 파일 |
| 관련항목 | SEE ALSO | 관련 커맨드나 참고 자료 |
| 버그 | BUGS | 커맨드와 관련해 이미 알려진 버그 |
| 저자 | AUTHOR | 커맨드 개발자 |

#### 3.  man 파일 내 검색
man 파일 검색에는 보통 whatis(1)과 apropos(1)을 자주 사용한다. whatis(1)는 검색 문자열로 지정한 커맨드명과 매치되는 man 파일의 요약문을 표시하고, apropos(1)은 지정된 검색 문자열을 커맨드명과 요약문에서 검색하여 표시한다.
```shell
$ whatis printf
printf(3) 		- formatted output conversion
printf(1)		- format and print data

$ apropos printf
asprintf(3)		- print to allocated string
dprintf(3)		- print to a file descriptor
fprintf(3)		- formatted output conversion
```

## 4. 사용자와 그룹
 리눅스는 멀티 사용자 시스템이므로 한 대의 PC를 여러 명의 사용자가 이용하는 경우 디렉터리나 파일, DVD드라이브에 대한 특정 사용자의 사용 허가를 제한하는 설정이 가능하다. 또한 이런 설정은 사용자별로 여러 명을 묶어 그룹으로도 설정할 수 있다.
 
 이러한 기능을 사용하기 위해서 리눅스에서는 사용자와 그룹이라는 개념을 사용한다. 시스템상에서는 사용자를 가리켜 **account(계정)**나, **user account(사용자 계정)**라고 부른다. 사용자를 하나로 묶는 경우는 그룹을 설정하여 해당 그룹에만 시스템 리소스에 대한 접근을 허가하도록 설정할 수 있다.
 
## 5. 허가권과 소유권
 한 사용자의 파일을 다른 사용자가 읽고 쓸 수 있기 때문에 접근권한을 제어해야 할 필요가 있다. 또한, 셸에서의 파일 실행 가능여부 등 속성을 각각 설정할 수 있다. 리눅스는 파일에 대한 사용자의 읽기 쓰기 실행 속성을 제어하는 **허가권(Permission)**이라는 액세스 제어 기능이 있다.
 
#### 1. 퍼미션
퍼미션은 ls(1)에 -al을 붙여 실행하면 확인할 수 있다. `-rw-r--r--`등이 허가권을 나타낸다.
`- rwx rwx rwx`
다음 형식은 차례대로 `user-group-others`를 나타낸다. rwx는 read, write, execute를 뜻하며 이 문자가 있으면 파일에 대한 해당 권한이 부여되어 있다는 것을 의미한다.

또한 각 플래그를 비트로 보면 이를 정수로 표현할 수 있다. 예를 들어 `r--`은 ㄱ만 비트가 설정되어 있으므로, 이진수로는 100, 십진수로는 4가된다. 마찬가지로 `rw--`는 이진수로 110, 십진수로 6이된다. 이 수치들은 파일의 허가권을 변경하는 chmod(1)모드 지정에도 이용되므로 알아두어야 한다.

| 기호 | 의미 | 정수 표현 |
|:--------:|:--------:|:--------:|
| r-- | 읽기 가능 | 4 |
| -w- | 쓰기 가능 | 2 |
| --x | 실행 가능 | 1 |
| rw- | 읽기, 쓰기 가능 | 6 |
| r-x | 읽기, 실행 가능 | 5 |
| rwx | 읽기, 쓰기, 실행가능 | 7 |

#### 2. 파일 타입
형식에서 가장 앞쪽에 위치한 `-`는 파일 타입을 나타낸다. 문자의 의미는 다음과 같다.

| 문자 | 파일 타입 |
|:--------:|:--------:|
| - | 일반 파일 |
| b | Block device파일 |
| c | Character device파일 |
| d | 디렉터리 |
| l | 심볼릭 링크 |
| p | FIFO(named pipe) |
| s | 소켓 |
| ? | 기타 파일 타입 |

퍼미션의 세 번째 문자에 복합적인 의미가 있는 문자가 들어가는 경우도 있다. 문자들의 의미는 다음과 같다.

| 문자 | 설명 |
|:--------:|:--------:|
| s | suid와 sgid의 실행권한 있음 |
| S | suid 또는 sgid로 설정되어 있으나, 실행 권한은 없음 |
| t | sticky bit가 설정되어 있으며, 타 사용자(other)의 실행 권한 있음 |
| T | sticky bit가 설정되어 있으나, 타 사용자는 실행 권한 없음 |
| x | 실행 권한이 있으며, 위 중 어느 것에도 해당하지 않음 |
| - | 위 중 어느 것에도 해당하지 않음 |

suid(set user id)는 파일의 소유자 권한으로 커맨드를 실행할 수 있다는 것을 의미한다. 또한 sgid(set group id)는 파일은 소유자 권한, 디렉터리인 경우에는 그 상위 디렉터리(부모 디렉터리)와 동일한 권한으로 실행할 수 있다는 것을 의미한다.

> sticky bit : 파일을 만든 사용자만이 삭제할 수 있도록 하는 비트, /tmp 디렉터리는 이 sticky bit 't'를 설정한다.

## 6. 파일
파일은 시스템을 이용하는 데 있어서 사람이 볼 수 있는 가장 작은 데이터의 단위이다. 파일은 데이터로 이루어져 있으며, 데이터의 최소 단위는 비트로, 0이나 1로 나타낸다. 문자와 8진수, 혹은 16진수 변환에 대해서는 UNIX 환경에서는 'man ascii'를 실행하면 변환 테이블을 메뉴얼로 참조할 수 있다.

파일명으로 쓸 수 있는 문자는 알파벳과 기호이며, 최근에는 한글이나 한자도 쓸 수 있게 되었다.

## 7. 디렉터리
디렉터리는 여러 개의 파일이나 디렉터리를 하나로 묶어 넣어두는 곳이다. UNIX에서는 트리구조로 구성하며 최상위 디렉터리를 `/(root:루트)`라고 하며 이 아래에 다른 디렉터리와 파일들이 배치된다.

현재 디렉터리를 기준으로 하나 위의 디렉터리를 **부모 디렉터리**, 하나 아래의 디렉터리를 **자식 디렉터리** 또는 **서브 디렉터리**라고 한다. 디렉터리의 이동에는 셸의 빌트인 커맨드인 cd를 사용한다.

# 2> 리눅스의 디렉터리 구성
## 1. 기본 지식
* FHS
 `FHS(Filesystem Hierarchy Standard)`는 리눅스 디렉터리 계층 구조 표준이다. 각 리눅스 배포자 혹은 다른 UNIX계열 시스템이 갖고 있던 각각의 고유한 디렉터리 구조를 통일하기 위한 것이다.

* mount(마운트)
 마운트는 HDD등의 Block device상의 파일 시스템을 시스템 디렉터리 트리의 일부에 설치하는 것을 말한다. 즉, HDD내의 파일 시스템을 시스템 디렉터리에 link하는 것이다.
 마운트 포인트는 디렉터리 구조상 분기점을 말하며, 마운트에는 mount(8)커맨드를, 시스템에서 디바이스를 제외할 때에는 umount(8)커맨드를 사용한다.

> 별도의 HDD를 증설할 때는 다음과 같은 절차를 따른다.
> 1. 시스템을 중지하고 전원을 끈다.
> 2. 증설할 HDD를 PC에 연결하고 시스템을 싱글 유저 모드로 부팅한다.
> 3. BIOS와 커널에서 인식을 확인한다. BIOS에서는 초기화면, 커널에서는 dmesg(1)등을 참조한다.
> 4. 시스템이 부팅되면 인식된 디바이스에 parted(8), fdisk(8) 커맨드로 파티션을 만든다.
> 5. 만들어진 파티션에 mkfs(8) 커맨드로 파일 시스템을 생성한다.
> 6. 생성된 파일 시스템을 마운트한다.
> 7. 기존 HDD의 데이터를 `/tmp/새로운디렉터리.new` 에 복사한다. 복사하려는 디렉터리르 지정한 후에, `/`를 넣느냐 넣지 않느냐에 따라 동작이 달라진다. 넣는 경우엔 복사할 새 디렉더리 아래에 복사하려는 원래 디렉터리가 생성돼 디렉터리 통채로 복사되지만, 넣지 않으면 복사하려는 원래 디렉터리에 있던 파일만을 새 디렉터리에 복사한다.
> 8. 현재 쓰고있는 마운트포인트 디렉터리 이름을 재 지정해준다.(이름이 같을 경우에만)
> 9. `/etc/fstab`를 편집하여 `dev/sdb1`을 복사한 디렉터리명으로 마운트하도록 변경한다.
> 10. 시스템 재부팅 또는 'mount -a'를 실행하여 제대로 마운트 되었는지를 df(1)등을 통해 확인한다. 에러가 난 경우에는 `etc/fstab`의 작성 방법이 다르지 않은지 파일 시스템의 지정이 잘못되어 있지 않은지 등 그 원인을 찾고, 이때 로그파일을 참고하면 좀 더 쉽게 해결할 수 있다.

* 파티션
 HDD를 여러 개의 영역으로 분할했을 때 생기는 한 영역을 가리키는 말이다. 파티션을 여러 개로 분할하는 것은 운용상의 몇가지 장점이 있다.
 첫째, 시스템 영역과 데이터 영역을 나눌 수 있다. 두가지 영역을 나눠두면 새 HDD에 데이터를 옮길 때 데이터 영역만 그대로 카피할 수 있어 작업이 간단해진다. 또한 두가지 영역 이외에 로그 영역을 만들어두면, 시스템영역과 데이터 영역의 용량이 꽉 차더라도 로그 영역에 여유만 있으면 시스템 부팅이 가능하다.
 둘째, LVM(Logical Volume Manager)이라는 디스크 영역 관리 기능을 이용하는 경우에도 파티션이 도움이 된다. LVM에서는 여러 개의 파티션을 묶어 하나의 논리 볼륨, 파티션으로 보이게 만들 수 있다. 따라서 여유 공간이 없어졌을 때 쓰지 않는 파티션을 추가하거나 HDD를 증설해서 파티션을 새로 분할하여 추가함으로써 영역을 확장할 수 있다.
 하나의 HDD에는 4개까지 파티션을 만들 수 있다. 왜냐하면 MBR(Maaster Boot Record)이라는 하드디스크의 첫 번째 섹터에 마련된 부트 로더를 저장하는 공간상의 제약 때문에 4개의 파티션까지밖에 기록이 불가하기 때문이다. 또한 기록할 수 있는 파티션은 `primary partition`과 `extended partition`을 포함해 4개가 된다.

## 2. / (Root)
루트는 최상위 디렉터리이다. 일반적으로 이 디렉터리 바로 아래에 vmlinuz라는 리눅스 커널 본체나 리눅스 커널 소스 패키지를 배치할 것을 권장한다.

## 3. /boot
`/boot`는 리눅스 커널, init ram fs파일, 부트 로더 GRUB의 설정 파일 등이 들어있는 디렉터리이다.

##### 1. System.map-2.6.32-5-amd64
리눅스 커널을 소스로 빌드하면 `System.map`이라는 이름으로 이 파일이 생성된다. 파일명 뒤쪽에는 리눅스 배포판의 커널 버전이 명시되어 있다. `System.map`은 리눅스 커널이 이용하는 심볼 테이블을 기록한 텍스트 파일로, 가상 주소와 커널 소스 내의 변수, 커널 심볼의 대응 등을 정리해 둔 것이다.
커널 심볼은 커널이 빌드될 때 결정되므로 이 대응표는 커널을 빌드할 때 `/boot`에 배치해 두는 것이 좋다. 이 파일은 기술되어 있는 가상 주소와 심볼을 이용해 커널 패닉이 발생했을 때 메세지를 참조해 디버깅하기 위한 파일이다.

> 커널패닉?
> 치명적인 에러가 커널에 발생했을 경우에 나타나는 현상이다. 시스템이 정지되고 강제종료 이외에는 별다른 방법이 없다. 보통 커널 패닉은 부팅 시 루트 파일 시스템(`/`가 포함된 파티션)을 읽어들이지 못했거나 커널 모듈이 폭주했거나 하드웨어가 고장날 경우 발생한다.
> window의 경우 블루스크린, Mac OS X에서는 검은 바탕에 커다란 전원 마크가 뜨면 커널패닉에 빠진것이다.

##### 2. config-2.6.32-5-amd64
리눅스 커널을 빌드했을 때 이용한 config파일의 백업파일. 리눅스 커널 버전 정보를 붙여두면 어떤 커널의 설정 파일인지 한눈에 알기 쉽다.

##### 3. grub
부트 로더 GRUB의 설정 파일이 들어 있는 디렉터리

##### 4. initrd.img-2.6.32-5-amd64
리눅스 커널 부팅시 사용하는 임시 파일 시스템, initrd는 **init ram disk**의 약자이다.

리눅스 커널은 시스템에서 사용하는 하드웨어에 맞춰 디바이스 드라이버를 커널 본체와 별도 파일로 빌드할 수 있다. 커널의 디바이스 드라이버는 `/lib/modules`아래에 설치되며 시스템 부팅 후 필요에 따라 커널에 적재할 수 있다. 단 이때 필요한 하드웨어의 디바이스 드라이버가 적재되지 않은경우에는 부팅되지 않는다. 이 경우에는 다음 두가지 방법을 사용하면 된다.

**1. 리눅스 커널에 필요한 디바이스 드라이버를 적재한 후 재빌드**
**2. initrd를 생성해 부팅 시 읽어들이게 함**

1번 방법은 부팅하는 커널에 디바이스 드라이브를 올리기 때문에 정상적으로 커널이 빌드되면 부팅이 된다. 2번 방법의 겨우 루트 파일 시스템, 디바이스 드라이버를 담은 작은 파일 시스템을 생성해 부팅 시 메모리에 올린다. 이것을 마운트함으로써 드라이버를 읽어들이고 부팅에 필요한 하드웨어들의 준비작업을 실행한다. 하드웨어들의 사용 준비가 완료되면 initrd로 올린 루트 파일 시스템을 삭제하고 HDD의 파일 시스템에 덮어씌워 부팅을 계속한다.

2번방법은 리눅스 커널을 출하하는 다수의 리눅스 배포판에서 채택하는 방식이다.

##### 5. vmlinuz-2.6.32-5-amd64
리눅스 커널 본체이다.

## 4. /etc
설정 파일을 저장하는 디렉터리이다. 설정 파일은 OS의 설정에 필요한 파일이나, 프로그램 설정 파일 등을 가리킨다. 디렉터리 이외에도 다음 표의 파일을 둘 것을 정의한다.

| 파일 | 설명 |
|:--------:|:--------:|
| exports | NFS파일 시스템의 엑세스 제어 리스트(옵션) |
| fstab | 파일 시스템의 정보(옵션) |
| gateways | 라우팅 테이블로서 게이트웨이 리스트(옵션), 배포판마다 다름 |
| group | 사용자 그룹 파일(옵션) |
| host.conf | Resolver(이름 분석 라이브러리)용 설정파일(옵션) |
| hosts | 호스트 명과 IP주소의 정적(static)정보(옵션) |
| hosts.allow | TCP Wrappers의 액세스 허가 리스트(옵션) |
| hosts.deny | TCP Wrappers의 액세스 거부 리스트(옵션) |
| inetd.conf | inetd의 설정 파일(옵션) |
| inittab | init의 설정 파일(옵션) |
| issue | 로그인 메시지와 시스템 정보 파일(옵션) |
| ld.so.conf | 공유 라이브러리의 검색 디렉터리 리스트(옵션) |
| motd | 'message of the day'의 약자, 로그인 후 login이 표시하는 텍스트파일(옵션) |
| mtab | 현재 마운트한 파일 시스템의 동적(dynamic)정보(옵션) |
| networks | 네트워크명과 네트워크 주소 링크 리스트(옵션) |
| passwd | 비밀번호 파일(옵션) |
| protocols | IP프로토콜 리스트(옵션) |
| resolv.conf | resolver 설정 파일(옵션) |
| securetty | root 로그인 시 tty 액세스 제어 파일(옵션) |
| services | 네트워크 서비스의 포트 번호와 이름 리스트(옵션) |
| shells | 유효한 로그인 셸에 쓸 수 있는 셸 경로명 리스트(옵션) |
| syslog.conf | syslog용 파일(옵션) |

## 5. /bin
시스템 관리자와 사용자가 사용하는 커맨드가 배치되어 있다. 이 디렉터리는 다른 파티션을 마운트하지 않아도 실행할 수 있는 커맨드를 모아놓았다. 즉 마운트 포인트 내의 bin 디렉터리의 명령어들은 해당 HDD를 마운트해주지 않으면 사용 불가하다.

## 6. /sbin
시스템 관리자가 이용하는 커맨드가 배치되어 있다. 시스템 시작, 데이터 백업이나 복원, 파티션 조정, 네트워크 설정등의 시스템 유지보수, 사용자의 추가와 삭제, 프로세스 감시 등에 필요한 커맨드들이 해당된다. `/bin`과 마찬가지로 첫번째 마운트 포인트의 `/sbin`이 `/sbin`으로 취급되며 하위 마운트 포인트 내부의 `/sbin`은 마운트해주지 않으면 사용할 수 없다.

## 7. /usr
시스템을 이용하는 사용자 간에 공유하는 데이터가 들어가 있는 디렉터리이다.
* /usr
 * /bin --> 사용자용 명령 위치
 * /include --> C프로그램에 include되는 헤더 파일 위치
 * /lib --> 라이브러리 파일 위치
 * /local --> 로컬용 파일 계층의 최상위
 * /sbin --> 시스템용 명령 위치
 * /share --> 아키텍쳐와 상관없는 데이터 파일(메뉴얼 등)위치

> /usr/local : 해당 pc용 소프트웨어를 넣어 두는 최상위 디렉터리

## 8. /home
사용자의 홈 디렉터리로 쓰인다. 시스템 사용자가 쓰는 셸의 설정 파일이나 메일, 데이터 파일 등을 보관한다. 일반적으로는 이 디렉터리에 프로그램을 설치하면 안되지만, `/home/사용자명/bin`등의 디렉터리를 만들어 `PATH=$PATH:$HOME/bin`을 설정해 두면 자신만의 프로그램을 쓸 수도 있다.
> Ubuntu나 Debian에서는 홈 디렉터리 아래에 bin이 있는 경우, 자동으로 해당 경로가 PATH에 추가된다.

## 9. /var
가변 데이터들을 보관해 두는 디렉터리이다. 스풀(임시로 배치하는 파일이나 디렉터리)이나 로그 등이 해당된다. 해당 디렉터리는 다음과 같은 자식 디렉터리를 가진다.

##### 1. /var/temp
임시 파일을 별도로 저장해 두는 곳, 디렉터리 퍼미션을 sticky bit가 설정된 `1777`로 설정한다.

##### 2. /var/(log,spool)
각 애플리케이션이 임시 파일을 저장해두는 스풀 디렉터리로, `/var/log`는 시스템의 일부 로그가 쓰이는 디렉터리이다. 커널의 메시지, syslog경유 메시지, httpd나 SMTP등 데몬에서 오는 메시지가 쓰인다.

##### 3. /var/mail
MTA(Mail Transfer Agent, SMTP 서버)에서 이용하는 디렉터리르 생성한다. SMTP 서버가 설정되어 있지 않아도 이 디렉터리는 준비해 두는 편이 좋다.

##### 4. /var/run
프로그램 실행시 할당되는 pid등을 텍스트 파일로 저장할때와 소켓 파일 등 임시데이터를 저장할 때 사용된다. 이는 다중 구동을 방지하며, 프로그램에 따라서는 `/tmp`를 사용하는 경우도 있다.

##### 5. /var/lock
프로그램 다중 구동을 막기 위한 임시 파일 저장에 이용된다. 프로그램마다 복수 구동이 불가능하게 되는 상황은 다름에 유의하자

##### 6. /var/{opt,cache,lib/{misc,locate},local}
데몬이나 로그의 임시 파일 저장 이외의 용도로 사용하는 디렉터리가 할당된다. `/var/opt`는 시스템 소속 패키지 이외의 소프트웨어에 이용되며 `/var/cache`는 시스템 데몬 중에서도 비교적 짧은 시간만 사용하는 데이터를 저장한다.

## 10. /proc
`/proc`은 `procfs(Process Files System)`라고 하며 리눅스 프로세스를 조작하거나 시스템 정보를 처리하는 수단을 제공하는 유사 파일 시스템(pseudo 파일 시스템)이다.

procfs는 원래 디버그 용도로 만들어졌으나 지금은 프로세스를 표시하는 ps(1), top(1)이나, kill(1), pkill(1)도 이 procfs를 참조하게 되어있다. 주요 파일 기록 내용은 아래 표와 같다.

| 내용 | 설명 |
|:--------:|:--------:|
| cmdline | 프로세스가 실행한 커맨드 행 |
| cwd | 프로세스의 current working directory의 심볼릭 링크 |
| environ | 프로세스의 환경 변수 |
| exe | 실행된 바이너리의 포인터 |
| fd | 프로세스가 오픈한 file descriptor의 목록이 들어 있는 서브 디렉터리 |
| maps | 프로세스 주소 공간(address space, 메모리)의 상태 |
| mem | 프로세스가 액세스한 내용 |
| mount | 프로세스 메모리에 마운트되어 있는 파일 시스템 |
| root | 파일 시스템의 루트 |
| stat | 프로세스의 상태 |
| statm | 메모리 사용 현황 |
| status | 프로세스의 상세한 상태 |

리눅스에서는 메모리나 스왑의 이용도가 극도로 높아지면 OOM Killer(Out Of Memory Killer)라는 서비스를 통해 구동 중인 프로세스에 시그널을 송신하여 프로세스를 강제 종료시켜 메모리 용량을 확보할 수 있다. OOM Killer에서는 커널이 프로세스를 검사하고 독자적인 기준에 따라 점수를 계산해 시그널을 송신할 프로세스를 결정한다. 이는 `/proc/프로세스ID/oom_score`에서 확인할 수 있다.

시스템 실행 시에 커널 파라미터를 procfs로 조정할수도 있다. `/proc/sys`에는 커널 파라미터를 나타내는 파일이 있어서 실행 중인 시스템을 재부팅하지 않고 커널 변수를 변경하려면 echo(1)등을 이용해 쓸 수 있다. 만약 시스템을 재부팅하면 초기화되어 다시 써야하는 상황이 생길 때에는 sysctl(8)을 사용한다.

## 11. /sys
sysfs는 메모리 내 파일 시스템을 통하여 사용자 프로세스에 커널 정보를 제공하는 기능이다. procfs가 프로세스, 커널 정보를 제공하는 가상 파일 시스템이라면, sysfs는 디바이스 정보를 제공하는 가상 파일 시스템이다. 부팅 시에 기본으로 마운트된다.

## 12. /dev
특수 디바이스 파일이 들어있는 디렉터리이다. 이 디렉터리가 없으면 커널이 하드웨어를 인식해도 입출력이 불가능하다. udev로 필요에 따라 동적으로 디바이스 파일을 생성하게 되어있으며 devtmpfs를 파일 시스템으로 채택하고 있다.

## 13. /tmp
시스템에서 작업 파일 등을 두는 디렉터리이다. tmpfs라는 유사 파일 시스템을 이용하며, 애플리케이션이 파일을 생성할 때에 임시 파일을 두거나 소켓 파일 등을 두게 된다. 이 파일 시스템은 메모리상에서 실행되므로 애플리케이션의 파일 입출력이 빠르고 때문에 언마운트하거나 재부팅하면 이 임시파일은 사라진다. 이런 임시파일들 중 중요하거나 다시 봐야할 파일들은 이 디렉터리에 저장된다.