# 1 > 부팅 스크립트와 설정 파일
리눅스 커널을 부팅할 때에는 루트 파일 시스템상의 init(8)을 실행한다. init(8)은 모든 프로세스의 부모 프로세스가 되어 자식 프로세스를 실행하며, 그 자식 프로세스들이 모두 종료되어도 init(8)프로세스만은 시스템 종료시까지 남아있다.

자식 프로세스에는 sshd(8)처럼 데몬으로 상주하는 프로세스 또는 키보드 설정만으로 부팅 시에 한 번 호출되는 것도 있다.

## 1. sysvinit
sysvinit은 대부분의 배포판에서 이용되는 부팅 도구 패키지이다. init은 커널의 하드웨어 초기화 후 커널이 구동하며, `/etc/inittab`을 설정 파일로 읽어들이고 파일에 있는 엔트리ID를 참조해 런레벨을 결정한다.

> **<?> 엔트리ID**
> 엔트리ID는 4문자까지 지정가능한 엔트리 식별 문자이다.


> **<?> 런레벨**
> 런레벨은 시스템의 서비스 실행을 단계별로 구분하여 적용함으로써 관리를 용이하게 하는것이다.
> 런레벨을 생략할 경우 기본 런레벨이 설정된다.
> * 0 - Halt : 시스템 종료
> * 1 - Single user mode : 시스템 복원모드, 관리자 권한 셸을 사용가능하다. 파일시스템 점검에도 사용 가능하다.
> * 2 - Multiuser mode : NFS(Network File System)를 지원하지 않는 다중 사용자 모드이다.
> * 3 - Full muliuser mode : 셸 기반의 인터페이스인 다중 사용자 모드이다. (CLI)
> * 4 - unused : 4번은 사용되지 않지만 정의해서 사용 가능하다.
> * 5 - X11 : 3번모드와 비슷하지만 GUI환경이다.
> * 6 - reboot : 시스템 재부팅

`/etc/inittab`은 파일 전체가 다음과 같은 포맷이 정해져있다.

```
id:runlevel:action:process
```

id에는 엔트리ID가, action은 동작을 정의하며, process는 실행하는 명령어를 지정한다.

## 2. upstart
upstart는 sysvinit을 대체하기 위해 Ubuntu의 프로젝트가 중심이 되어 개발한 패키지이다.

sysvinit은 런레벨 별로 init 스크립트를 나누어 프로세스 구동이나 정지를 관리하지만, upstart는 커널이나 동작 중인 프로세스에서 받는 실행, 중지 이벤트를 통해서 다른 프로세스의 서비스 실행 혹은 중지, 또는 예기지 못한 프로세스의 중지가 발생했을 시 재부팅을 지원하는 등 sysvinit보다는 한층 더 발전된 구동 시스템이다.

upstart는 sysvinit과의 호환성을 위해서 런레벨의 개념은 그대로 사용하는 대신 **event**와 **job**개념을 바탕으로 동작한다.

구동시 `.conf`확장자 파일을 job으로 사용가능하며, sysvinit에서 쓰는 설정 파일도 사용할 수 있다.

#### job의 기술 방법
job파일은 `/etc/init/`아래에 `job이름.conf`로 생성한다. 또한 각 job파일 내에서 지정하는 각 항목은 **스탠자**라고 명명하며 각 job파일은 job의 실행 및 중지를 담당한다.

* start on / stop on : 이벤트를 받는 스탠자
* emit : 이벤트를 주는 스탠자

스탠자에는 크게 두가지 유형이 있다. **task**는 짧은 프로세스로, 처리가 종료되면 job도 종료된다. **service**는 apache와 같은 데몬 job으로서, task가 명시적으로 쓰여 있지 않은 경우에는 service로 분류된다.

또한 job파일은 bash 베이스의 스크립트도 처리 가능하며 쓰이는 스탠자는 다음과 같다.

| 명령어 | 기능 |
|:--------:|:--------:|
| pre-start | 프로세스 실행 전에 처리 |
| post-start | 프로세스 실행 후에 처리 |
| pre-stop | 프로세스 종료 전에 처리 |
| post-stop | 프로세스 종료 후에 처리 |

스크립트는 `pre-start script`부터 `end script`를 감싼 부분이다.

이외에도 자주 쓰이는 스탠자는 다음과 같다.

| 명령어 | 기능 |
|:--------:|:--------:|
| env | 환경 변수를 정의 |
| exec | job으로 실행하려는 프로세스의 파일을 지정, 실해 |
| respawn | exec로 실행한 프로세스가 종료된 경우 재시작 |
| umask | 프로세스의 umask를 지정 |
| kill timeout | 지정한 시간이 경과한 후 프로세스에 SIGTERM, SIGKILL을 보냄 |
| expect | 데몬으로서 동작시키는 방법을 지정해 PID를 upstart에 통보<br>fork는 1번 fork, daemon은 2번 fork |
| normal exit | job 종료 조건이 되는 프로세스로부터의 반환 값을 정의 |
| console | 출력할 곳을 지정 |

#### initctl 사용
upstart는 job관리에 initctl(8)을 사용한다.
주요 기능은 다음 표와 같다.

| 커맨드 | 기능 |
|:--------:|:--------:|
| start | 뒤에 job 이름을 지정해 프로세스를 시작<br>job 이름 뒤에 '변수=값'으로 환경변수 지정 가능 |
| stop | 뒤에 job 이름을 지정해 프로세스를 종료<br>'변수=값'을 뒤에 지정하면 환경변수 지정 가능 |
| restart | job을 stop하고 start함 |
| reload | job 프로세스에 SIGHUP을 보낸다 |
| status | 프로세스 상태 표시 |
| list | job 리스트 표시 |
| emit | 이벤트명을 지정하여 해당 이벤트를 발생시킴 |
| reload-configuration | init(8)의 설정파일을 다시 읽어들임<br>갱신되면 자동으로 다시 읽어들이도록 설정되어있음 |
| log-priority | job의 우선도를 지정 |
| show-config | job 파일의 일부 내용을 표시 |
| check-config | job 파일 리스트에서 실행할 수 없거나 중지할 수 없는 job파일을 확인 |

## 3. systemd
systemd는 sysvinit을 대체하기 위한 init 데몬이다. 처리 병렬화, UNIX 소켓과 D-Bus를 이용한 서비스 실행, Linux 프로세스 컨트롤 그룹(cgroups)기능을 이용한 프로세스 추적, 시스템 상태 스냅샷 생성/복원등이 가능하다.

systemd에서는 런레벨이 **타깃**이라는 개념으로 쓰이며, **타깃**은 **유닛**의 집합이다. 이때 유닛은 systemd가 다루는 조작 대상이다.

#### systemd의 구성
**sysvinit**에서는 init이 구동되고, `/etc/inittab`으로부터 런레벨을 읽어와 디렉터리 아래의 데몬 구동 스크립트를 실행한다. 이 안에 syslog도 포함되어 있어서 시스템의 로그가 syslogd경유로 로그에 기록되거나 httpd의 경우는 독자적으로 로그를 기록한다.

반면 **systemd**는 구동시에 `/etc/systemd/system,config`, `/etc/systemd/user.config` 두가지 설정 파일을 읽어온다. 이후에 `--unit`에서의 지정이 없으면, `/etc/systemd/system/default.config`를 읽어온다.

systemd는 journald라는 독자적인 로깅 시스템을 가지고 있으며, systemd와 동시에 구동된다. 하지만 syslogd가 존재하는 환경과의 호환성을 고려해 rsyslogd와 소켓을 경유해 시스템 로그가 기록되어있다.

#### systemd의 유닛

| 유닛 | 내용 |
|:--------:|:--------:|
| systemd.service | 데몬이나 프로세스 정의 |
| systemd.socket | 로컬 IPC, 네트워크 소켓, FIFO |
| systemd.device | /dev/아래의 디바이스 파일 정의 |
| systemd.mount | 마운트 포인트 정의 |
| systemd.automount | 자동 마운트 포인트 정의 |
| systemd.swap | 스왑 디바이스 정의 |
| systemd.target | 유닛을 묶은 타깃 정의 |
| systemd.path | 특정 파일의 경로 정의 |
| systemd.timer | 특정 시간에 실행하는 처리 정의 |
| systemd.snapshot | 스냅샷 정의 |

#### systemd 설정 파일
systemd는 `/etc/inittab`을 읽어들이지 않고, `/etc/systemd/system/default.targer`을 먼저 읽어온다.

#### 서비스의 등록/실행/중지/재실행
서비스를 실행하려면 systemctl(8)에 start 커맨드와 서비스명을 지정한다.
```
$ sudo systemctl start httpd
```

서비스가 실행된 뒤에는 systemctl(8)로 상태를 확인한다.
```
$ systemctl | grep httpd
```

상세정보를 얻기 위해서는 status 커맨드를 사용한다.
```
$ systemctl status httpd
```

서비스를 중지할 때는 stop 커맨드를 사용한다.
```
$ sudo systemctl stop httpd
```

시스템 구동 시 서비스도 자동 시작하게 하려면 enable 커맨드를 사용한다.
```
$ sudo systemctl enable httpd
$ sudo systemctl disable httpd
```
enable 커맨드를 통해 `/tec/systemd/system/[타깃]/`아래의 해당 서비스 파일의 심볼릭 링크가 추가, 삭제되며 이는 sysvinit의 chkconfig(8)에 해당한다.

## 4. 파티션과 마운트 포인트 설정(/etc/fstab)
`fstab`에는 아래와 같은 내용이 기술되어있다. 

##### 1. 블록 디바이스
마운트할 블록 디바이스, 원격 파일 시스템을 지정한다. `호스트이름:디렉터리명`으로 구분하여 지정한다. 또한 블록 디바이스 대신에 LABEL, UUID도 이용할 수 있다. 이는 장치에 붙이는 일종의 표식으로, 마운트포인트, 옵션을 구분한다.

SATA나 SCSI의 접속 방법에 따라 파일명이 `/dev/sda` -> `/dev/sdb`로 변경되는 경우 등에 도움이 된다.

##### 2. 마운트 포인트
마운트 포인트는 `/boot`나 `/var`등 FHS에 보이는 디렉터리 이름을 지정한다.

##### 3. 파일시스템
ext2나 ext4등의 파일시스템을 지정한다. 지원하는 파일 시스템은 `/proc/filesystems`에서 확인 가능하다.

##### 4. 마운트 옵션
mount(8)실행 시에 이용하는 옵션을 반점으로 구분하여 복수 지정한다.

##### 5. 덤프
dump(8)은 파일 시스템 단위로 백업하는 명령어로, ext2/ext3/ext4를 지원한다.
백업시에 백업 대상에 포함할것인지 아닌지는 1(포함)/0(제외)로 구분해 설정한다.

##### 6. 파일 시스템 확인 순서
시스템 구동 시 파일시스템 확인(fsck) 순서를 나타낸다. 루트 파일 시스템은 1을 지정하고 0이나 공란의 경우 fsck를 실행하지 않는다.

## 5. 커맨드라인 입력 지원 라이브러리(/etc/inputrc)
`/etc/inputrc`는 readline 라이브러리에서 이용하는 설정파일로, 단축키를 설정한다.

| 동작 | 단축키 |
|:--------:|:--------:|
| 한 문자 왼쪽으로 이동 | `Ctrl` + `b` |
| 한 문자 오른쪽으로 이동 | `Ctrl` + `f` |
| 행 첫머리로 이동 | `Ctrl` + `a` |
| 행 끝으로 이동 | `Ctrl` + `e` |
| 커맨드 이력 검색 | `Ctrl` + `r` |
| 바로 앞 커맨드 표시 | `Ctrl` + `p` |
| 하나 뒤 커맨드 표시 | `Ctrl` + `n` |
| 행 끝까지 삭제 | `Ctrl` + `k` |

# 2 > 사용자와 그룹 정의 파일
## 1. UNIX의 사용자와 그룹
UNIX의 사용자는 관리자 사용자(root), 시스템 사용자, 일반사용자로 나뉜다.

보통 보안상의 이유로 시스템 사용자 권한을 많이 사용하며, 배포판에 따라 그 취급이 달라지지만 다음과 같은 공통점이 있다.

> 1. 사용자 생성 커맨드의 설정파일 `/etc/adduser.conf`등에서 시스템 사용자 ID의 범위가 정해져 있다.
> 2. `/etc/shadow`를 확인해보면 시스템 사용자의 비밀번호는 설정되어 있지 않다.

일반사용자는 관리자 root와 시스템 사용자가 이용하고 있지 않은 ID를 이용하여 시스템을 이용하기만 하는 사용자를 뜻한다. 시스템 설정, 서버 설정, 패키지 설치는 불가하며 시스템에 로그인해 설치된 커맨드만을 사용할 수 있다.

한편 각 사용자는 그룹이라는 소속을 설정할 수 있으며, 최소 하나의 그룹에는 들어가 있어야한다. UNIX에서는 계정을 생성하거나 변경하는 경우를 제외하고는 표준에서 사용자명과 같은 이름의 그룹이 생성되며 자동으로 속하게 된다.

## 2. 비밀번호 파일(/etc/passwd)
UNIX 계정 정보가 기록된 파일은 `/etc/passwd`이다. 파일에는 `:`으로 구분지어진 다음과 같은 내용이 저장되어 있다.

1. UNIX 사용자명
2. 비밀번호
3. 사용자 ID
4. 그룹 ID
5. 주석
6. 홈 디렉터리
7. 셸

비밀번호의 경우엔 x가 들어가고, 비밀번호 자체는 암호회되어 `/etc/shadow`에 기록되어 있다.
각 ID는 숫자로 이루어져 있으며, 주석은 `,`으로 구분하여 여러개의 정보를 넣을 수 있다.

## 3. 암호화한 비밀번호 저장(/etc/shadow)
`/etc/shadow`는 암호화 된 비밀번호 파일을 관리자 권한으로만 접근할 수 있도록 한다. 하지만 과거에는 일반사용자도 접근할 수 있었기 때문에 무차별 대입 공격등을 받기도 했다.

이에 대한 대책으로 NIS, LDAP, Shadow Password 등이 이용되고 있다.

`/etc/shadow`의 각 행은 다음과 같이 기술된다.
```
로그인명:암호화된 비밀번호:1970년 1월1일부터 비밀번호가 최종 갱신된 날까지의 일수:비밀번호 변경 가능까지의 일수:비밀번호 변경 경고까지의 일수:비밀번호 미변경 후 계정을 이용할 수 없게 되기까지의 일수:비밀번호의 유효 기한이 만료된 뒤 게정이 무효화 되기까지의 일수:1970년 1월1일부터 계정을 이용할 수 없게 되기까지의 일수:예약 영역
```

암호화 비밀번호 부분은 $로 구분지으며 ID, Salt, Encrypted로 나뉜다.
```
$id$salt$encrypted
```

ID는 이용하는 해시 알고리즘을 나타내며, 1은 MD5, 2는 Blowfish, 5는 SHA-256, 6은 SHA-512를 이용한다. Salt는 사용자의 비밀번호를 암호화하기 위한 문자열이며, Encrypted는 ID로 지정한 해시 알고리즘으로, 해시화한 비밀번호 문자열이다.

비밀번호는 비밀번호 이외에도 `!`로 비밀번호가 설정되어 있지 않음, `*`로는 계정 잠금, `!!`로는 비밀번호 유효 기한 만료등을 표시한다.

만약 `/etc/passwd`나 `/etc/shadow`를 편집하고싶으면 툴을 이용해야한다. 편집시에 다른 사용자가 비밀번호를 변경하거나 할 경우 중복 안전의 안전성이 보장되지 않기 때문이다. 만약 꼭 에디터로 변경해야 한다면 vipw(8)을 사용하는것이 좋다. 이 커맨드는 실행하면 잠금이 걸리므로 다른 사용자와 동시 실행이 불가능해지며 만약 서식이 틀렸을 때는 경고를 표시하고 저장하지 않기 때문이다.

다음은 사용자의 생성, 삭제나 비밀번호의 설정, 변경 등에 사용하는 명령어이다.

| 도구 | 설명 |
|:--------:|:--------:|
| adduser/useradd | 사용자 추가 |
| deluser/userdel | 사용자 삭제 |
| groupadd/groupdel | 그룹 추가/삭제 |
| usermod | 사용자 계정 수정 |
| groupmod | 그룹 계정 수정 |
| passwd | 비밀번호 변경 |
| change | 비밀번호 유효 기한 변경 |
| chsh | 셸 변경 |
| chfn | 이름 정보 변경 |

## 4. 사용자 그룹 파일(/etc/group, /etc/gshadow)
`etc/group`은 시스템의 그룹을 정의하는 파일이다. group파일은 한 행에 한 그룹을 정의하며 형식은 다음과 같다.
```
그룹명:비밀번호:그룹ID:사용자명
```
그룹 ID는 숫자이며, 사용자명에는 여러 사용자를 동시에 기술 가능하다.

사용자는 여러 그룹에 소속될 수 있지만, 만약 사용자명과 그룹에 같은 이름이 있는 경우, 해당 그룹의 읽/쓰기 설정을 적절히 설정해 두어야 한다. 때문에 가능하면 다른 이름을 쓰는것이 좋다.

그룹은 다음과 같이 생성하며, -g옵션으로 그룹 Id도 지정 가능하다. 만약 따로 지정해주지 않을경우에는 99이상의 비어있는 번호 중 하나가 할당된다.
```
$ sudo groupadd 그룹명
```

그룹 비밀번호를 변경할때는 gpasswd를 실행한다
```
$ sudo gpasswd 그룹명
```

그룹도 마찬가지로 `/etc/group`과는 별도로 `/etc/gshadow`가 존재하며 각 행의 형식은 다음과 같다.
```
그룹명:암호화 비밀번호:관리자:멤버
```
암호화 비밀번호에는 id, salt, encrypted등이 해당된다.

만약 `/etc/group`과 `/etc/gshadow`가 문법적으로 올바르게 기술되었는지를 조사하고 싶으면, grpck(8)을 사용하면 되고, 에디터를 사용하고 싶을 경우에는 vigr(8)명령어를 사용하면 된다.

# 3 > 네트워크 설정 스크립트
## 1. 리눅스의 네트워크 기능
##### <?> 이더넷?
> 이더넷은 컴퓨터 간 네트워크를 구성하는 규격으로, 기업이나 일반 가정에서 널리 이용하고 있다. 일반 가정에서는 광케이블 라우터나 ADSL라우터와 PC를 LAN케이블로 연결해 인터넷에 접속하고 TCP/IP프로토콜로 데이터 통신을 실시한다.

리눅스 환경의 통신에서는 애플리케이션이 커널에 데이터를 보낸다. 이후에 커널은 TCP/IP에 따라서 패킷을 생성하고, **LAN 케이블이 꽂혀있는 이더넷 어댑터 칩**에 패킷을 보낸다. 칩은 패킷을 전기 신호로 바꾸어 케이블로 보내고 전기 신호가 흐르면 **LAN 케이블에 꽂혀있는 포트의 이더넷 어댑터 칩**이 신호를 수신하고 리눅스 커널은 신호를 받고 다시 애플리케이션에 전달하게 된다.

## 2. TCP/IP
#### 1. TCP/IP
데이터 통신시에 프로토콜에 따라서 주고받아야한다. 현재 이더넷을 구성하는 기본 프로토콜로는 TCP와 IP가 있다.

TCP/IP는 맨 처음 UNIX에서 지원하였으며, 보급되기 전에는 벤더가 각각 준비한 프로토콜을 사용자에게 제공했었기 때문에, 해당 벤더의 기기로 네트워크를 한 번 구축해 놓으면 사실상 그 벤더를 기준으로 개발, 운용을 해야하는 벤더종속이었다. 하지만 TCP/IP의 보급으로 벗어나게 되었다.

TCP/IP의 인터넷 통신 계층 구조는 다음과 같다. 아래로 내려갈수록 하드웨어 구현에 가까워진다.
이러한 계층구조는 각 계층이 다른 것으로 대체되더라도 혹은 통신하고자 하는 환경이 이더넷 혹은 PPP를 사용해도 대응할 수 있게 하기 위해서이다.

* 애플리케이션 층
* 트랜스포트 층
* 네트워크 층
* 링크 층

##### 애플리케이션 층 / 트랜스포트 층
애플리케이션 층은 HTTP가 대표적인 프로토콜이며, 트랜스포트 층은 TCP/UDP등이 있다. 두가지 방법 모두 상대방과의 포트 번호로 통신하지만, TCP의 경우는 재전송요구, 오류검출 등을 실시해 통신흐름을 제어한다.

##### 네트워크 층
통신 상대를 향해 패킷을 보내기 위한 관리를 한다. 어떤 네트워크를 경유할 것인지(라우팅), 어떤 프로토콜을 이용할 것인가(IPv4, IPv6)등을 고려한다.

##### 링크 층
물리적인 네트워크에 패킷을 보내는 층이다. LAN에서 이용하는 이더넷이나 전화선을 통한 PPP등을 이용해 패킷을 전송한다.

#### 2. IP주소
IP주소는 네트워크상의 단말기를 식별할 수 있게해주는 ID이다. IPv4는 0-255의 숫자가 4개 나열된 주소를 단말기에 설정한다. PC는 이를 진수로 표현해 32비트로 저장한다.

> ipcalc 사용시 bad prefix 해결

## 3. 네트워크 설정 동작
##### 네트워크 인터페이스 설정 파일
CentOS나 Red Hat등의 RPM계열 배포판에서는 `/etc/init.d/network`가 네트워크 설정 스크립트가 되고, 시스템이 먼저 `/etc/sysconfig/network`에 네트워크 이용에 대해 지정한다.

네트워크 인터페이스 설정은 `/etc/sysconfig/network-scripts/ifcfg-디바이스명`에 IP주소와 설정 옵션등을 기술한다. 디바이스 명으로는 etho0 또는 eth1, 무선 LAN장치라면 wlan0등이 사용된다. 

RPM 계열 네트워크 인터페이스 설정 파일의 주요 파라미터는 다음과 같다.

| 파라미터 | 설정 값 |
|:--------:|:--------:|
| BOOTPROTO | none - 부트 프로토콜을 사용하지 않는다.<br>bootp - BOOTP를 사용한다.<br>dhcp - DHCP를 사용한다. |
| BROADCAST | 브로드캐스트 어드레스를 지정한다.(필수x) |
| IPADDR | IP주소 |
| DEVICE | etho0과 같은 물리 장치명을 지정한다. |
| GATEWAY | 기본 게이트웨이의 IP주소를 지정한다. |
| HWADDR | MAC 어드레스를 지정한다. 복수 NIC를 장착한 PC인 경우 각각의 장치명을 구분해 부여하기 위해 이용된다. |
| NETMASK | 넷마스크 값을 지정한다. |
| NETWORK | 네트워크 주소를 지정한다.(필수x) |
| ONBOOT | yes - 부팅 시 유효화<br>no - 부팅시 유효화 되지 않음 |
| USERCTL | yes - root 사용자가 아닌 사용자도 장치를 제어할 수 있다.<br>no - root 사용자만 장치를 제어할 수 있다. |

## 4. 이름 분석 조회용 DNS 서버를 지정 (/etc/resolv.conf)
##### 이름 분석의 필요성
매번 웹 사이트의 IP주소를 일일히 기억하기에는 어렵기 때문에, DNS(Domain Name System)으로 IP주소와 호스트 이름을 이어주게 되었다. 도메인은 인터넷상에서 중복되지 않게 네트워크상의 이름을 관리하는 것을 말하고 kr이나 com을 톱 레벨 도메인(TLD)이라고 하며 ICANN이 관리하고있다. 세컨드 레벨 도메인부터 도메인 이름으로 사용한다.

도메인은 ISP나 레지스트러로부터 구입할 수 있고, 구입한 이후 DNS서버를 마련해 해당 도메인으로 운영하게 된다. DNS 서버는 IP 주소와 호스트 이름 리스트를 가진 서버로, 인터넷상의 단말기에서 질의가 오면 이름 또는 IP 주소, 호스트의 별명 등을 반환하며, 전 셰게의 DNS 서버를 통해 분산된 데이터베이스로 가동되고 있다.

##### DNS의 종류(콘텐츠 서버, 캐시 서버)
DNS 서버에는 **권한을 양도**받아 도메인 정보를 제공하는 콘텐츠 서버와 다른 DNS를 **조회**하여 도메인 정보를 캐시하는 캐시 서버가 있다. 캐시 서버는 LAN 내부에서 쿼리를 받아서 자신이 해당 정보를 가지고 있지 않으면 인터넷의 DNS에 이를 조회한다.

> IPS에서는 캐시 서버가 해당 계약자의 네트워크 내, 조직이나 가정에서는 해당 LAN에서만 접근되는 것이 바람직하지만, Google Public DNS와 같이 광범위한 캐시 서비스를 제공하는 DNS도 있다.
> 악성 DNS 서버가 잘못된 정보를 캐시 서버에 보내는 DNS Cache Poisoning Attack이 있으므로 캐시 서버를 외부에 제공하는 것은 삼가는 것이 좋다.

##### 이름 분석 방법
1. 단말기는 캐시 서버에 타깃 서버의 호스트 이름, IP 주소를 조회한다.
2. 캐시 서버가 이 정보를 갖고 있지 않으면 해당 도메인을 관리하는 DNS 서버에 질의한다.
3. 캐시 서버가 해당 도메인을 관리하는 DNS 서버를 알 수 없으면 루트 네임 서버에 질의한다.

> 캐시 서버는 자신이 루트 네임 서버 리스트를 가지고 있다. IANA에서는 오픈소스 DNS 데몬 bind 용으로 공개하고있다.

##### resolv.conf의 서식
리눅스를 단말기로 이용할 때 시스템 라이브러리의 libc에 있는 resolver라는 리졸버 루틴이 `/etc/resolv/conf`에 기재된 DNS 서버를 이름 분석을 위한 캐시 서버로 이용한다.

주요 파라미터는 다음과 같다.

| 파라미터 | 설명 |
|:--------:|:--------:|
| domain | 도메인 이름을 생략하여 질의하는 경우 덧붙이는 도메인 이름 |
| search | 검색할 도메인 이름으로 최대 6개까지 공백 또는 탭으로 구분 지어 지정할 수 있다. |
| nameserver | 이름 분석을 위한 DNS 서버를 지정한다. 최대 3개까지 등록할 수 있으며 위부터 차례로 조회한다. |

# 4 > 패킷 필터링
리눅스 커널에는 IP 패킷 필터링 프레임워크 **Netfilter**와 이를 이용하기 위한 커맨드라인 프론트엔드 **iptables(8)과 ip6tables(8)**가 준비되어 있다.
iptables(8)를 이용해 아래와 같은 네트워크 환경을 구축할 수 있다.

* 파일 필터링으로 한 대의 호스트를 요새화
* 인터넷과 LAN을 연결하나 인터넷에서 LAN 호스트를 감춤
* LAN 호스트에서 인터넷으로의 접속성을 확보하고 출발지 주소를 변환
* LAN의 특정 호스트에 패킷을 전송
* 로드밸런싱, 부하분산(한정적)

> IP 패킷 필터링은 IP 패킷의 헤더를 참조해 통과/파기/전송 등의 처리를 하는 것을 말한다.

## 1. 리눅스에서 iptables/Netfilter 동작하기
##### iptables(8)가 설치되었는지 확인하기
1. CentOS
```
$ rpm -qa | grep iptables
```
2. Debian
```
$ dpkg -l | grep iptables
```

##### Netfilter옵션 설정 확인
iptables(8)을 이용하려면 리눅스 커널이 Netfilter 프레임워크를 이용할 수 있도록 설정되어 있어야한다. RPM 계열, DEB 계열 모두 커널 설정은 `/boot/config-<커널 버전>`에서 확인할 수 있다.
```
$ grep -i netfilter /boot/config-'uname -r'
```

만약 옵션이 유효하지 않다면 `make menuconfig`를 사용해 커널 모듈을 유효화하여 재구축해야한다.

> 이용가능한 모듈 확인법
> ```
> $ sudo modprobe -l -t netfilter -a
> ```

## 2. TCP/IP, ICMP, 패킷 필터
iptables(8)은 패킷 헤더의 출발지, 목적지, TCP/UDP/ICMP프로토콜, 80/http나 25/smtp 등의 목적지 포트와 출발지 포트 등 패킷 헤더에 포함된 정보를 바탕으로 필터링을 실시한다.

##### 스테이트풀 방화벽(stateful firewall, 상태 추적형 방화벽)
LAN에서의 인터넷 접근을 허가하고 인터넷에서 LAN에 배치된 단말기를 보호하는 방화벽을 구축하는 경우 LAN에서 인터넷으로 나가는 패킷을 통과시키는 것은 물론, 이에 대한 LAN 단말기로 들어오는 응답 패킷 통과도 허가해야만 한다.

##### 연결 추적
TCP는 접속 확립을 위해 실행되는 **3way handshake** 작업의 패킷 상태를 바탕으로 패킷이 **접속상태**에 있는지 판단한다. 이를 stateful filtering 이라고 한다.

## 3. iptables 작성법
##### 규칙 = 매칭 + 타깃
규칙 작성은 패킷 헤더의 추출과 해당 패킷의 처리를 정의하는 것을 말한다. 규칙 포맷은 다음과 같다.
```
iptables -A <체인> <매칭옵션> -j <타깃>
```

iptables(8)의 주요 옵션

| 옵션 | 의미 |
|:--------:|:--------:|
| -t 테이블 | 이용할 테이블을 지정한다. 기본은 'filter' |
| -A 체인 | 지정하는 체인에 규칙을 추가한다. |
| -m 모듈 | 매칭 모듈을 지정한다. 이 옵션 다음에 모듈 별 옵션을 추가할 수 있다. |
| -p 프로토콜 | tcp/udp/icmp/all 중 하나를 지정한다. 기본은 all |
| -d 도착지 주소 | 도착지 주소 지정 |
| -s 출발지 주소 | 출발지 주소 지정 |
| --dport 포트 | 도착지 포트 지정. -p tcp또는 -p udp와 함께 사용한다. |
| --sport 포트 | 출발지 포트 지정. -p tcp또는 -p udp와 함께 사용한다. |
| -i 인터페이스 | 패킷이 들어오는 네트워크 인터페이스를 지정한다. |
| -o 인터페이스 | 패킷이 나가는 네트워크 인터페이스를 지정한다. |
| -j 타깃 | ACCEPT나 DROP등의 타깃을 지정한다. |

-m으로 확장 매칭 모듈을 사용해 타깃 패킷 범위를 좁힐 수 있다. 대표적인 확장 매칭 모듈은 다음과 같다.

| 모듈 | 용도 |
|:--------:|:--------:|
| addtype | UNICAST나 ANYCAST 등 주소 타입을 지정하여 매칭함 |
| conntrack | 연결 추적 매칭 |
| connlimit | 한 IP의 동시 접속 수 제한 |
| iprange | IP 주소 폭을 지정하여 매칭함 |
| mac | MAC 주소로 매칭함 |
| multiport | 1:1024로 1부터 1024 까지를 지정, 22,80,443과 복수 포트 번호를 지정하여 매칭함 |
| state | 연결 추적과 함께 패킷의 상태로 매칭함 |

이 중에서도 state사용은 매우 중요하다. state 모듈은 iptables(8)의  `--state`를 이용해 다음과 같이 기술한다.
```
iptables -A FORWARD -i eth0 -o eth1 -m state --state ESTABLISHED, RELATED -j ACCEPT
```

`ESTABLISHED`, `RELATED` 이 두가지가 확장 모듈의 옵션이다. `--state`에 대한 인수는 탐지할 패킷의 상태를 지정한다. 이 구문은 eth0에서 eth1로 전송하는 패킷에서 접속상태(ESTABLISHED)또는 접속 상태에 있는 패킷의 관련 패킷(RELATED)을 ACCEPT하는 규칙이다.

`--state`의 옵션 인수는 다음과 같다.

| state인수 | 탐지하는 패킷의 상태 |
|:--------:|:--------:|
| NEW | 처음 보는 패킷 |
| ESTABLISHED | 접속 요구(SYN)후 응답(SYN/ACK)이 있었던 또는 응답 후에 ACK가 와서 접속상태가 되는 패킷 |
| RELATED | 접속 상태인 패킷과 관련된 패킷, FTP의 데이터 포트(20/tcp)는 이것을 이용함 |
| INVALID | NEW, ESTABLISHED, RELATED 이외의 패킷, 대부분이 drop해도 되는 패킷 |

타깃으로 이용할 수 있는 파라미터는 다음과 같다.

| 타깃 | 의미 |
|:--------:|:--------:|
| ACCEPT | 패킷을 통과시킴 |
| DROP | 패킷을 버림 |
| QUEUE | 사용자 공간으로 패킷을 들여보냄 |
| RETURN | 체인을 종료함(체인 호출 시점으로 돌아감) |

##### 체인 = 규칙 + 규칙 + etc
`-A INPUT`에는 체인을 지정한다.. 체인이라는 것은 규칙의 집합이며 이때 순번도 매우 중요하게 작용된다. 패킷은 규칙 순서대로 매칭되어서 중요한 패킷을 누락시키는 경우도 있으니 주의하자.

먼저 정책을 DROP하여 표준 타깃을 만들고 그 뒤에 통과시킬 패킷을 지정하는 것이 표준 체인의 사용법이다.

##### 테이블 = 체인 + 체인
특별히 -t로 테이블을 지정하지 않는 경우 **filter**테이블이 생성된다. filter이외의 테이블과 체인은 다음과 같다.

| 테이블 | 목적 | 이용가능 표준 체인 |
|:--------:|:--------:|:--------:|
| filter | 목적 패킷을 필터링 | INPUT, OUTPUT, FORWARD |
| nat | 출발지 또는 도착지 주소를 변환 | OUTPUT, PREROUTING, POSTROUTING |
| mangle | TTL 등 패킷 헤더를 수정 | INPUT, OUTPUT, PREROUTING, POSTROUTING |
| raw | 연결 추적을 하지 않는 변환 실시 | OUTPUT, PREROUTING |

패킷 헤더 수정이 필요하지 않으면 filter와 nat만 사용해도 된다.

> DNAT : 도착지 타깃
> SNAT : 출발지 타깃
> MASQUERADE : 하나 이상의 NIC 또는 네트워크를 가지고 있으면 한 쪽에서 다른 쪽으로 패킷을 전달할 때 사용하는 기술(=NAT)

mangle 테이블은 TTL(Time To Live, 라우터를 거칠 때마다 감소하는 패킷 생존 수치)값을 조정하여 LAN에서 얼마 만큼의 라우터를 거쳤는지 등의 정보들을 외부 네트워크로 새어나가지 않도록 막거나 TOS 타깃을 이용해 라우팅할 곳을 조정한다.

이들 테이블에 체인을 구축하면 된다. 체인 용도는 다음과 같다.

| 체인 | 목적 |
|:--------:|:--------:|
| INPUT | 패킷 입력 규칙을 정의 |
| OUTPUT | 패킷 출력 규칙을 정의 |
| FORWARD | 패킷 전송 규칙 정의 |
| PREROUTING | 입력 전 패킷 변환 |
| POSTROUTING | 입력 후 패킷 변환 |

체인은 사용자가 독자적으로 만들 수 있으며 -N으로 사용자 정의 체인을 만들고 -A로 지정, 패킷 매칭과 타깃을 지정한다. 위의 표는 기본 내장 체인으로, 사용자가 독자적으로 체인을 만들 때에는 가장 마지막에 DROP이나 REJECT를 지정해야한다.

## 4. logging
타깃에 LOG나 ULOG를 지정하면 syslog나 ulog에 패킷 로그를 기록할 수 있으며 해당 규칙을 통과한 후 다음 규칙의 검토에 들어간다. 이때는 타깃의 DROP이나 REJECT 규칙을 다시 한 번 추가해야한다.

패킷 로그는 기본으로 커널 로그에 기록되며 로그 facility를 변경할 때에는 `--log-level`을 이용한다. 또한 prefix를 지정 가능하며 `--log-prefix`로 문자열을 지정해두면 기록된 패킷이 어느 규칙에 매치되었는지 판단할 수 있다.

## 5. 패킷 필터 스크립트 작성
iptables(8)로 패킷 필터링을 구축할 때 규칙 정의에는 iptables(8)를 실행하게 되지만, 원격으로 수동 입력하는 경우에 첫 기본 정책에서 타깃에 DROP을 지정하면 이후에는 원격 접근을 할 수 없다. 원격 환경에서는 가능한 iptables를 건드는 것은 피하는게 좋지만 불가피할 때는 스크립트를 이용한다. **기본 정책 실행 후에 원격 접근 가능한 규칙까지 한번에 추가하면 이와 같은 문제를 피할 수 있다.**

> 또한 IP등을 변수화하는것도 범용성이 좋으므로 규칙을 스크립트로 만들어 두는게 좋다.

## 6. 디버그 방법
iptables 규칙을 스크립트로 만들어 디버그할 때에는 셸의 echo를 이용한다. 
```
$ IPT -A INPUT -i $EXDEV -p TCP --sport 22 -j ACCEPT || echo "ssh/tcp input rul failed."
```

## 7. iptables 규칙 부팅 스크립트
CentOS에서는 `/etc/init.d/iptables` 규칙을 유효화 하는 스크립트가 있고, 이 스크립트는 `iptables-restore(8)`에 규칙의 덤프 파일을 입력하면 유효화 된다. 설치 시에 패킷 필터링을 유효화한 경우 `/etc/sysconfig/iptables`에는 몇가지 규칙이 있다. 만약 사용자가 규칙을 만들면 이를 적용하여 iptables-save(8)로 덤프한다.

Debian 계열에서는 `/etc/network/interfaces`에 pre-up 커맨드로 기술하거나 `/etc/network/if-pre-up.d/`아래에 스크립트를 만들면 된다.

# 5 > udev
udev는 리눅스 커널용 디바이스 파일 관리 도구이다. USB 메모리나 USB 키보드 등 PC를 재부팅하지 않고 바로 쓸 수 있는 핫플러그 기기는 삽입한 순간 /dev에 해당 디바이스 파일이 생성되지 않으면 장치를 사용할 수 없기 때문에 udev는 이들 디바이스 파일을 관리한다.

리눅스 커널 구동 후 init 경유로 udevd라는 데몬을 실행한다. PC에 하드웨어가 삽입되면 커널이 sysfs가 작성하는 /sys 아래의 정보를 참고해 udevd에 하드웨어가 추가되었음을 통보한다. udevd는 이렇게 받은 통보에미리 자신이 가진 규칙에 근거해 디바이스에 대한 액션을 실행한다. 규칙은 `/etc/udev/rules.d` 아래에 들어있다.

> udevd 설정파일 : /etc/udev/udev/conf
> udevd 규칙파일 : /lib/udev/rules.d/*.rules || /etc/udev/rules.d/*.rules

## 1. udev 설정파일
udev 전체 설정 파일은 두 개의 파라미터를 지정할 수 있다.

| 파라미터 | 설명 |
|:--------:|:--------:|
| udev_root | 파일 시스템상의 어느 위치에 디바이스 파일을 배치할지 정함. 기본은 /dev |
| udev_log | 로깅 우선도를 지정. syslog의 priority 번호나 err, info등의 문자를 지정 |

## 2. udev 규칙 파일
커널에서 이벤트를 받으면 udev가 참조하는 규칙 파일은 다음 3개 디렉터리에 위치한다.
1. `/lib/udev/rules.d(기본 규칙 디렉터리)`
2. `/etc/udev/rules.d(커스터마이즈용 규칙 디렉터리)`
3. `/run/dev/rules.d(임시 규칙 디렉터리)`

만약 1과 2에 같은 이름의 규칙이 있으면 2의 규칙이 유효하고 1은 무시된다. 때문에 만약 시스템 커스터마이즈를 할 경우 2에 규칙을 작성해야한다.

규칙 디렉터리에는 여러 개의 규칙 파일을 넣어둘 수 있으며 `.rules` 확장ㅇ자이며 숫자로 시작한다. 왜냐하면 규칙 파일을 읽어들이는 순서가 정렬순(숫자가 작은 쪽부터)이기 때문이다.

규칙은 한 행에 적어도 한 쌍의 키/값이 들어가도록 작성된다. 이때 `키=값` 또는 `키==값`으로 연결된다. 만약 `==`로 연결되면 검증을 실시한다는 의미이며, `=`는 대입의 의미, `!=`는 매치되지 않는경우를 뜻한다. 이외에도 `+=`, `:=`등등이 있다.

udev 규칙의 의미에는 다음과 같은 것들이 있다.

| 키 | 값 | 의미 |
|:--------:|:--------:|:--------:|
| SUBSYSTEM | net | 매치하는 이벤트 디바이스의 서브 시스템 |
| ACTION | add | 매치하는 이벤트 액션명 |
| DRIVERS | ?* | 매치하는 이벤트 디바이스의 드라이버 이름 |
| ATTR{address} | 00:XX:4d:XX:fa:XX | 매치하는 sysfs의 파일명을 첨자로 하는 이벤트 디바이스 값 |
| ATTR{dev_id} | 0x0 | 위와 같음 |
| ATTR{type} | 1 | 위와 같음 |
| KERNEL | eh* | 매치하는 커널 디바이스 명 |
| NAME | eh0 | 설정할 디바이스 명 |

udev의 규칙 관리는 특별히 불편하지 않다면 실행되고 있는 udev에 맡겨두는 것이 좋다. 새 디바이스를 시스템에 연결하면 해당 장치의 ID 등을 udev가 취득해 규칙에 추가해준다. 만약 디바이스 이름이 중복될 우려가 있으면 숫자에 +1연산을 해 저장한다. 만약 먼저 접속한 NIC와 새 NIC의 인터페이스 이름을 서로 바꾸고 싶으면 규칙 파일에서 변경하면 된다.

udev 규칙 파일은 생성, 갱신이 감시되고 있기 때문에 저장하는 즉시 적용된다.