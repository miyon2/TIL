# 1 > 부팅 스크립트와 설정 파일
리눅스 커널을 부팅할 때에는 루트 파일 시스템상의 init(8)을 실행한다. init(8)은 모든 프로세스의 부모 프로세스가 되어 자식 프로세스를 실행하며, 그 자식 프로세스들이 모두 종료되어도 init(8)프로세스만은 시스템 종료시까지 남아있다.

자식 프로세스에는 sshd(8)처럼 데몬으로 상주하는 프로세스 또는 키보드 설정만으로 부팅 시에 한 번 호출되는 것도 있다.

## 1. sysvinit
sysvinit은 대부분의 배포판에서 이용되는 부팅 도구 패키지이다. init은 커널의 하드웨어 초기화 후 커널이 구동하며, `/etc/inittab`을 설정 파일로 읽어들이고 파일에 있는 엔트리ID를 참조해 런레벨을 결정한다.

> **<?> 엔트리ID**
> 엔트리ID는 4문자까지 지정가능한 엔트리 식별 문자이다.


> **<?> 런레벨**
> 런레벨은 시스템의 서비스 실행을 단계별로 구분하여 적용함으로써 관리를 용이하게 하는것이다.
> 런레벨을 생략할 경우 기본 런레벨이 설정된다.
> * 0 - Halt : 시스템 종료
> * 1 - Single user mode : 시스템 복원모드, 관리자 권한 셸을 사용가능하다. 파일시스템 점검에도 사용 가능하다.
> * 2 - Multiuser mode : NFS(Network File System)를 지원하지 않는 다중 사용자 모드이다.
> * 3 - Full muliuser mode : 셸 기반의 인터페이스인 다중 사용자 모드이다. (CLI)
> * 4 - unused : 4번은 사용되지 않지만 정의해서 사용 가능하다.
> * 5 - X11 : 3번모드와 비슷하지만 GUI환경이다.
> * 6 - reboot : 시스템 재부팅

`/etc/inittab`은 파일 전체가 다음과 같은 포맷이 정해져있다.

```
id:runlevel:action:process
```

id에는 엔트리ID가, action은 동작을 정의하며, process는 실행하는 명령어를 지정한다.

## 2. upstart
upstart는 sysvinit을 대체하기 위해 Ubuntu의 프로젝트가 중심이 되어 개발한 패키지이다.

sysvinit은 런레벨 별로 init 스크립트를 나누어 프로세스 구동이나 정지를 관리하지만, upstart는 커널이나 동작 중인 프로세스에서 받는 실행, 중지 이벤트를 통해서 다른 프로세스의 서비스 실행 혹은 중지, 또는 예기지 못한 프로세스의 중지가 발생했을 시 재부팅을 지원하는 등 sysvinit보다는 한층 더 발전된 구동 시스템이다.

upstart는 sysvinit과의 호환성을 위해서 런레벨의 개념은 그대로 사용하는 대신 **event**와 **job**개념을 바탕으로 동작한다.

구동시 `.conf`확장자 파일을 job으로 사용가능하며, sysvinit에서 쓰는 설정 파일도 사용할 수 있다.

#### job의 기술 방법
job파일은 `/etc/init/`아래에 `job이름.conf`로 생성한다. 또한 각 job파일 내에서 지정하는 각 항목은 **스탠자**라고 명명하며 각 job파일은 job의 실행 및 중지를 담당한다.

* start on / stop on : 이벤트를 받는 스탠자
* emit : 이벤트를 주는 스탠자

스탠자에는 크게 두가지 유형이 있다. **task**는 짧은 프로세스로, 처리가 종료되면 job도 종료된다. **service**는 apache와 같은 데몬 job으로서, task가 명시적으로 쓰여 있지 않은 경우에는 service로 분류된다.

또한 job파일은 bash 베이스의 스크립트도 처리 가능하며 쓰이는 스탠자는 다음과 같다.

| 명령어 | 기능 |
|:--------:|:--------:|
| pre-start | 프로세스 실행 전에 처리 |
| post-start | 프로세스 실행 후에 처리 |
| pre-stop | 프로세스 종료 전에 처리 |
| post-stop | 프로세스 종료 후에 처리 |

스크립트는 `pre-start script`부터 `end script`를 감싼 부분이다.

이외에도 자주 쓰이는 스탠자는 다음과 같다.

| 명령어 | 기능 |
|:--------:|:--------:|
| env | 환경 변수를 정의 |
| exec | job으로 실행하려는 프로세스의 파일을 지정, 실해 |
| respawn | exec로 실행한 프로세스가 종료된 경우 재시작 |
| umask | 프로세스의 umask를 지정 |
| kill timeout | 지정한 시간이 경과한 후 프로세스에 SIGTERM, SIGKILL을 보냄 |
| expect | 데몬으로서 동작시키는 방법을 지정해 PID를 upstart에 통보<br>fork는 1번 fork, daemon은 2번 fork |
| normal exit | job 종료 조건이 되는 프로세스로부터의 반환 값을 정의 |
| console | 출력할 곳을 지정 |

#### initctl 사용
upstart는 job관리에 initctl(8)을 사용한다.
주요 기능은 다음 표와 같다.

| 커맨드 | 기능 |
|:--------:|:--------:|
| start | 뒤에 job 이름을 지정해 프로세스를 시작<br>job 이름 뒤에 '변수=값'으로 환경변수 지정 가능 |
| stop | 뒤에 job 이름을 지정해 프로세스를 종료<br>'변수=값'을 뒤에 지정하면 환경변수 지정 가능 |
| restart | job을 stop하고 start함 |
| reload | job 프로세스에 SIGHUP을 보낸다 |
| status | 프로세스 상태 표시 |
| list | job 리스트 표시 |
| emit | 이벤트명을 지정하여 해당 이벤트를 발생시킴 |
| reload-configuration | init(8)의 설정파일을 다시 읽어들임<br>갱신되면 자동으로 다시 읽어들이도록 설정되어있음 |
| log-priority | job의 우선도를 지정 |
| show-config | job 파일의 일부 내용을 표시 |
| check-config | job 파일 리스트에서 실행할 수 없거나 중지할 수 없는 job파일을 확인 |

## 3. systemd
systemd는 sysvinit을 대체하기 위한 init 데몬이다. 처리 병렬화, UNIX 소켓과 D-Bus를 이용한 서비스 실행, Linux 프로세스 컨트롤 그룹(cgroups)기능을 이용한 프로세스 추적, 시스템 상태 스냅샷 생성/복원등이 가능하다.

systemd에서는 런레벨이 **타깃**이라는 개념으로 쓰이며, **타깃**은 **유닛**의 집합이다. 이때 유닛은 systemd가 다루는 조작 대상이다.

#### systemd의 구성
**sysvinit**에서는 init이 구동되고, `/etc/inittab`으로부터 런레벨을 읽어와 디렉터리 아래의 데몬 구동 스크립트를 실행한다. 이 안에 syslog도 포함되어 있어서 시스템의 로그가 syslogd경유로 로그에 기록되거나 httpd의 경우는 독자적으로 로그를 기록한다.

반면 **systemd**는 구동시에 `/etc/systemd/system,config`, `/etc/systemd/user.config` 두가지 설정 파일을 읽어온다. 이후에 `--unit`에서의 지정이 없으면, `/etc/systemd/system/default.config`를 읽어온다.

systemd는 journald라는 독자적인 로깅 시스템을 가지고 있으며, systemd와 동시에 구동된다. 하지만 syslogd가 존재하는 환경과의 호환성을 고려해 rsyslogd와 소켓을 경유해 시스템 로그가 기록되어있다.

#### systemd의 유닛

| 유닛 | 내용 |
|:--------:|:--------:|
| systemd.service | 데몬이나 프로세스 정의 |
| systemd.socket | 로컬 IPC, 네트워크 소켓, FIFO |
| systemd.device | /dev/아래의 디바이스 파일 정의 |
| systemd.mount | 마운트 포인트 정의 |
| systemd.automount | 자동 마운트 포인트 정의 |
| systemd.swap | 스왑 디바이스 정의 |
| systemd.target | 유닛을 묶은 타깃 정의 |
| systemd.path | 특정 파일의 경로 정의 |
| systemd.timer | 특정 시간에 실행하는 처리 정의 |
| systemd.snapshot | 스냅샷 정의 |

#### systemd 설정 파일
systemd는 `/etc/inittab`을 읽어들이지 않고, `/etc/systemd/system/default.targer`을 먼저 읽어온다.

#### 서비스의 등록/실행/중지/재실행
서비스를 실행하려면 systemctl(8)에 start 커맨드와 서비스명을 지정한다.
```
$ sudo systemctl start httpd
```

서비스가 실행된 뒤에는 systemctl(8)로 상태를 확인한다.
```
$ systemctl | grep httpd
```

상세정보를 얻기 위해서는 status 커맨드를 사용한다.
```
$ systemctl status httpd
```

서비스를 중지할 때는 stop 커맨드를 사용한다.
```
$ sudo systemctl stop httpd
```

시스템 구동 시 서비스도 자동 시작하게 하려면 enable 커맨드를 사용한다.
```
$ sudo systemctl enable httpd
$ sudo systemctl disable httpd
```
enable 커맨드를 통해 `/tec/systemd/system/[타깃]/`아래의 해당 서비스 파일의 심볼릭 링크가 추가, 삭제되며 이는 sysvinit의 chkconfig(8)에 해당한다.

## 4. 파티션과 마운트 포인트 설정(/etc/fstab)
`fstab`에는 아래와 같은 내용이 기술되어있다. 

##### 1. 블록 디바이스
마운트할 블록 디바이스, 원격 파일 시스템을 지정한다. `호스트이름:디렉터리명`으로 구분하여 지정한다. 또한 블록 디바이스 대신에 LABEL, UUID도 이용할 수 있다. 이는 장치에 붙이는 일종의 표식으로, 마운트포인트, 옵션을 구분한다.

SATA나 SCSI의 접속 방법에 따라 파일명이 `/dev/sda` -> `/dev/sdb`로 변경되는 경우 등에 도움이 된다.

##### 2. 마운트 포인트
마운트 포인트는 `/boot`나 `/var`등 FHS에 보이는 디렉터리 이름을 지정한다.

##### 3. 파일시스템
ext2나 ext4등의 파일시스템을 지정한다. 지원하는 파일 시스템은 `/proc/filesystems`에서 확인 가능하다.

##### 4. 마운트 옵션
mount(8)실행 시에 이용하는 옵션을 반점으로 구분하여 복수 지정한다.

##### 5. 덤프
dump(8)은 파일 시스템 단위로 백업하는 명령어로, ext2/ext3/ext4를 지원한다.
백업시에 백업 대상에 포함할것인지 아닌지는 1(포함)/0(제외)로 구분해 설정한다.

##### 6. 파일 시스템 확인 순서
시스템 구동 시 파일시스템 확인(fsck) 순서를 나타낸다. 루트 파일 시스템은 1을 지정하고 0이나 공란의 경우 fsck를 실행하지 않는다.

## 5. 커맨드라인 입력 지원 라이브러리(/etc/inputrc)
`/etc/inputrc`는 readline 라이브러리에서 이용하는 설정파일로, 단축키를 설정한다.

| 동작 | 단축키 |
|:--------:|:--------:|
| 한 문자 왼쪽으로 이동 | `Ctrl` + `b` |
| 한 문자 오른쪽으로 이동 | `Ctrl` + `f` |
| 행 첫머리로 이동 | `Ctrl` + `a` |
| 행 끝으로 이동 | `Ctrl` + `e` |
| 커맨드 이력 검색 | `Ctrl` + `r` |
| 바로 앞 커맨드 표시 | `Ctrl` + `p` |
| 하나 뒤 커맨드 표시 | `Ctrl` + `n` |
| 행 끝까지 삭제 | `Ctrl` + `k` |

# 2 > 사용자와 그룹 정의 파일
## 1. UNIX의 사용자와 그룹
UNIX의 사용자는 관리자 사용자(root), 시스템 사용자, 일반사용자로 나뉜다.

보통 보안상의 이유로 시스템 사용자 권한을 많이 사용하며, 배포판에 따라 그 취급이 달라지지만 다음과 같은 공통점이 있다.

> 1. 사용자 생성 커맨드의 설정파일 `/etc/adduser.conf`등에서 시스템 사용자 ID의 범위가 정해져 있다.
> 2. `/etc/shadow`를 확인해보면 시스템 사용자의 비밀번호는 설정되어 있지 않다.

일반사용자는 관리자 root와 시스템 사용자가 이용하고 있지 않은 ID를 이용하여 시스템을 이용하기만 하는 사용자를 뜻한다. 시스템 설정, 서버 설정, 패키지 설치는 불가하며 시스템에 로그인해 설치된 커맨드만을 사용할 수 있다.

한편 각 사용자는 그룹이라는 소속을 설정할 수 있으며, 최소 하나의 그룹에는 들어가 있어야한다. UNIX에서는 계정을 생성하거나 변경하는 경우를 제외하고는 표준에서 사용자명과 같은 이름의 그룹이 생성되며 자동으로 속하게 된다.

## 2. 비밀번호 파일(/etc/passwd)
UNIX 계정 정보가 기록된 파일은 `/etc/passwd`이다. 파일에는 `:`으로 구분지어진 다음과 같은 내용이 저장되어 있다.

1. UNIX 사용자명
2. 비밀번호
3. 사용자 ID
4. 그룹 ID
5. 주석
6. 홈 디렉터리
7. 셸

비밀번호의 경우엔 x가 들어가고, 비밀번호 자체는 암호회되어 `/etc/shadow`에 기록되어 있다.
각 ID는 숫자로 이루어져 있으며, 주석은 `,`으로 구분하여 여러개의 정보를 넣을 수 있다.

## 3. 암호화한 비밀번호 저장(/etc/shadow)
`/etc/shadow`는 암호화 된 비밀번호 파일을 관리자 권한으로만 접근할 수 있도록 한다. 하지만 과거에는 일반사용자도 접근할 수 있었기 때문에 무차별 대입 공격등을 받기도 했다.

이에 대한 대책으로 NIS, LDAP, Shadow Password 등이 이용되고 있다.

`/etc/shadow`의 각 행은 다음과 같이 기술된다.
```
로그인명:암호화된 비밀번호:1970년 1월1일부터 비밀번호가 최종 갱신된 날까지의 일수:비밀번호 변경 가능까지의 일수:비밀번호 변경 경고까지의 일수:비밀번호 미변경 후 계정을 이용할 수 없게 되기까지의 일수:비밀번호의 유효 기한이 만료된 뒤 게정이 무효화 되기까지의 일수:1970년 1월1일부터 계정을 이용할 수 없게 되기까지의 일수:예약 영역
```

암호화 비밀번호 부분은 $로 구분지으며 ID, Salt, Encrypted로 나뉜다.
```
$id$salt$encrypted
```

ID는 이용하는 해시 알고리즘을 나타내며, 1은 MD5, 2는 Blowfish, 5는 SHA-256, 6은 SHA-512를 이용한다. Salt는 사용자의 비밀번호를 암호화하기 위한 문자열이며, Encrypted는 ID로 지정한 해시 알고리즘으로, 해시화한 비밀번호 문자열이다.

비밀번호는 비밀번호 이외에도 `!`로 비밀번호가 설정되어 있지 않음, `*`로는 계정 잠금, `!!`로는 비밀번호 유효 기한 만료등을 표시한다.

만약 `/etc/passwd`나 `/etc/shadow`를 편집하고싶으면 툴을 이용해야한다. 편집시에 다른 사용자가 비밀번호를 변경하거나 할 경우 중복 안전의 안전성이 보장되지 않기 때문이다. 만약 꼭 에디터로 변경해야 한다면 vipw(8)을 사용하는것이 좋다. 이 커맨드는 실행하면 잠금이 걸리므로 다른 사용자와 동시 실행이 불가능해지며 만약 서식이 틀렸을 때는 경고를 표시하고 저장하지 않기 때문이다.

다음은 사용자의 생성, 삭제나 비밀번호의 설정, 변경 등에 사용하는 명령어이다.

| 도구 | 설명 |
|:--------:|:--------:|
| adduser/useradd | 사용자 추가 |
| deluser/userdel | 사용자 삭제 |
| groupadd/groupdel | 그룹 추가/삭제 |
| usermod | 사용자 계정 수정 |
| groupmod | 그룹 계정 수정 |
| passwd | 비밀번호 변경 |
| change | 비밀번호 유효 기한 변경 |
| chsh | 셸 변경 |
| chfn | 이름 정보 변경 |

## 4. 사용자 그룹 파일(/etc/group, /etc/gshadow)
`etc/group`은 시스템의 그룹을 정의하는 파일이다. group파일은 한 행에 한 그룹을 정의하며 형식은 다음과 같다.
```
그룹명:비밀번호:그룹ID:사용자명
```
그룹 ID는 숫자이며, 사용자명에는 여러 사용자를 동시에 기술 가능하다.

사용자는 여러 그룹에 소속될 수 있지만, 만약 사용자명과 그룹에 같은 이름이 있는 경우, 해당 그룹의 읽/쓰기 설정을 적절히 설정해 두어야 한다. 때문에 가능하면 다른 이름을 쓰는것이 좋다.

그룹은 다음과 같이 생성하며, -g옵션으로 그룹 Id도 지정 가능하다. 만약 따로 지정해주지 않을경우에는 99이상의 비어있는 번호 중 하나가 할당된다.
```
$ sudo groupadd 그룹명
```

그룹 비밀번호를 변경할때는 gpasswd를 실행한다
```
$ sudo gpasswd 그룹명
```

그룹도 마찬가지로 `/etc/group`과는 별도로 `/etc/gshadow`가 존재하며 각 행의 형식은 다음과 같다.
```
그룹명:암호화 비밀번호:관리자:멤버
```
암호화 비밀번호에는 id, salt, encrypted등이 해당된다.

만약 `/etc/group`과 `/etc/gshadow`가 문법적으로 올바르게 기술되었는지를 조사하고 싶으면, grpck(8)을 사용하면 되고, 에디터를 사용하고 싶을 경우에는 vigr(8)명령어를 사용하면 된다.