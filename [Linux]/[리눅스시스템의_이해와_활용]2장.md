# 1> 셸 사용하기
## 1. 셸이란?
OS의 중심인 커널을 둘러싼 '껍질'이라 생각하면 쉽다. 셸은 사용자의 입력을 받아서 커널을 사용하며, 커널에서 실행을 입력받아 사용자에게 출력한다. 셸은 다음과 같은 수행을 담당한다.
* 애플리케이션의 구동
* 프로그램 실행 순서의 변경
* 변수 저장
* 실행 커맨드 이력 저장
* 결과 출력

셸은 사전에 커맨드를 기술해 둔 텍스트 파일을 읽어들이며 차례대로 실행한다. 또한 셸 스크립트 파일로 시스템 부팅 시에 환경 변수를 설정하거나 조건 분기하여 실행하는 프로그램을 변경할 수 있다.

## 2. 셸의 종류
시스템에서 기본으로 쓰는 셸을 알려면 `/bin/sh`가 어느 셸에 심볼릭 링크되어 있는지 확인해보면 된다. 대부분은 `/bin/bash`나, `/bin/dash`에 링크되어 있다.

#### 1. bash
현재 거의 모든 리눅스 배포판에서 표준으로 채택된 셸이다.

#### 2. csh/tcsh
C Shell이라는 계열의 셸이다. 현재는 tcsh가 주류로 사용된다. 많은 BSD계열 UNIX에서 표준 셸로 채택되어 있다.

#### 3. dash
Debian GNU/Linux나 Ubuntu가 표준셸로 채택하고 있으며 bash보다 가볍다.

#### 4. zsh
bash와 마찬가지로 'Bourne Shell'을 개량한 셸이다. ksh를 기반으로 하며, bash나 tcsh의 편리한 기능도 많이 채택하고 있다.

## 3. 셸의 기능
#### 1. 커맨드 프롬프트
셸은 사용자와 대화할 수 있는 인터페이스를 제공한다.

```
$
```

#### 2.프로그램 실행 동작
프로그램 구동 형식은 다음과 같다.

```
$ 프로그램명 인수
```

프로그램명에는 파일의 경로를 지정해주어야 하고, 만약 매번 경로지정해주는게 귀찮다면 파일의 절대경로를 PATH에 등록해주면 실행시에 환경 변수에서 알아서 찾아준다.

인수는 프로그램에 따라 입력하는 문자열이 달라진다. 때문에 사용가능한 인수와 인수 사용방법을 잘 알아두는게 중요하다. 만약 사용 불가능한 인수를 넘기면 **command not found** 메세지가 표시된다.

리눅스의 커맨드 라인에서 권리자 권한은 `#`, 관리자 이외의 권한은 `$`가 사용된다.

#### 3. 자동완성 기능과 히스토리 기능
커맨드가 길 경우 커맨드의 일부분만 타이핑 한뒤 `Tab`키를 두번 눌러주면 사용가능한 커맨드 목록이 표시된다. 이외에도 이전에 실행했던 프로그램을 다시 실행하려고 할 때에는 히스토리 기능을 사용할 수 있다.
커맨드 히스토리 이용 방법은 다음과 같다.

| 표시 | 조작 |
|:--------:|:--------:|
| 하나 앞의 커맨드 표시 | `Ctrl` + `p`/`윗방향키` |
| 하나 뒤의 커맨드 이력 표시 | `Ctrl` + `n`/`아래방향키` |
| 커맨드 실행 이력 맨 처음을 표시 | `Esc` + `<` |
| 현재 입력 중인 행을 표시 | `Esc` + `>` |
| 과거 사용한 커맨드 검색 | `Ctrl` + `r`(뒤에 커맨드 패터 입력) |
| 직전에 입력한 커맨드의 가장 마지막 인수를 표시 | `Esc` + `.`|

#### 4. 작업(job)제어 기능
셸에는 복수 프로그램의 실행이나 중지를 관리하는 작업 제어 기능이 있다.
* foreground job : 사용자가 보는 바로 앞에서 실행
* background job : 뒤에서 실행
* suspend job : 중지중

작업 제어 기능을 사용하면 특정 프로그램을 중지하거나, 포어그라운드로 복귀 혹은 백그라운드 실행 등으로 변경할 수 있다.

##### #example

```
$ emacs -nw
[1]+ Stopped emacs
$ w3m
[2]+ Stopped w3m
$ jobs
[1]- Stopped emacs
[2]+ Stopped w3m
$ fg 1
$ fg 2
```

emacs(1)은 에디터에서 프로세스가 종료될 때까지 셸로 돌아오지 않는다.
1. 만약 `Ctrl` + `z`를 할 경우 emacs 프로세스를 중지한다.
2. 프로세스가 종료되었으므로 셸로 돌아온다. 이때 w3m을 입력한다. (텍스트 베이스 웹 브라우저로 프로세스를 종료할 때까지 셀로 돌아오지 않음)
3. `Ctrl` + `z`로 w3m 프로세스를 중지한다.
4. 셸로 돌아와 jobs를 입력한다. (셸의 내장 커맨드이며 작업 상태를 리스트로 보여준다.)
5. fg 1과 fg 2로 emacs와 w3m을 재개한다.

#### 5. 리다이렉션과 파이프
* 리다이렉션 : 프로그램의 출력을 파일로 기록
* 파이프 : 프로그램의 출력을 타 프로그램 입력에 사용

** 1. 리다이렉션 **
`>`, `<`, `>>`로 파일 디스크립터(표준 입력은 0, 포준 출력은 1, 표준 에러 출력은 2)를 지정하여 프로그램의 입출력할 곳을 변경한다.
```
$ sed -e "s/perl/ruby/g" address.txt < address2.txt
$ sed -e "s/perl/ruby/g" < address.txt
$ sed -e "s/perl/ruby/g" < address.txt > address2.txt
$ echo "php" >> file
```

1. sed의 처리 결과를 **address2.txt**에 출력한다. `>`를 붙이면 화면에 처리 결과가 표시되지 않는다.
2. sed(1)입력에 파일인 **address.txt**를 사용한다. 출력할 곳은 변경되지 않으므로 화면에 처리 결과가 표시된다.
3. 입력을 address.txt, 출력을 address2.txt로 하는 내용이다. 결과는 화면에 기록되지 않고 address.txt에 기록된다. `>`는 이미 파일이 있다면 한 번 비워낸 후에 기록한다.
4. `>>`를 사용하면 결과를 이어서 추가로 기록한다.

`>`와 `<`는 파일 디스크립터를 생략한 것으로 원래는 `1>`, `0<`라고 쓴다. 0은 표준 입력, 1은 표준출력을 나타내는 파일 디스크립터 넘버이며 2는 표준 에러 출력이다.

만약 표준 에러 출력을 무시하고 표준 출력만을 화면에 표시하고 싶은 경우에는 다음과 같이 입력하면 된다.
```
$ sed -e "s/perl/ruby/g" address.txt 2> /dev/null
```

`&`을 붙여 출력과 에러 출력을 하나로 묶을 수도 있다.
```
$ sed -e "s/perl/ruby/g" address.txt 2>&1
```

파일에도 기록하고 화면에도 출력하고 싶을 경우엔 tee(1)을 사용하면 된다.
```
$ sed -e "s/perl/ruby/g" address.txt 2>&1 | tee /tmp/log.txt
```

** 2. 파이프**
파이프는 `|`를 이용해 프로그램의 출력을 다른 프로그램의 입력에 쓰도록 하는 것이다.

# 2> 셸 커맨드
## 1. 내장 커맨드란?
프로그램을 실행하는 셸 자체에 포함된 커맨드다. 반대로 셸이 가진 기능이 아닌 별도의 프로그램을 외부 명령어라고 한다.
> 외부명령어를 사용하기 위해서는 경로를 설정해 두거나 전체경로(full PATH)를 입력하여 해당 프로그램을 실행해야한다.

내장 커맨드는 type으로 확인할 수 있으며, bash 매뉴얼 에서는 `SHELL BUILTIN COMMANDS`라는 항목에서 내장 커맨드를 확인할 수 있다.

## 2. 주요 내장 커맨드

#### 1. 아무것도 하지 않고 종료 코드 0을 반환
`:`만으로도 하나의 커맨드가 될 수 있다. 실행 시 0을 종료 상태로 반환하기 때문에 for나 while등 무한 루프 스크립트에 이용할 수 있다.

#### 2. 다른 셸 스크립트를 불러와 실행한다.
source 또는 온점으로 현재 셸 환경에서 다른 셸 스크립트를 불러와 실행한다. `.`을 사용하면 뒤의 지정된 스크립트의 변수나 함수를 실행, 해당 스크립트를 이용할 수 있게 된다.
```
. /etc/default/cups
source /etc/default/cups
```

#### 3. 지정된 디렉터리로 이동한다.
cd 는  현재디렉터리(working directory)에서 타 디렉터리로 이동할 시 사용하는 커맨드이다. 아무것도 지정해주지 않으면 홈 디렉터리로 이동한다.

환경변수 CDPATH를 설정하면 cd 뒤에 이동할 디렉터리 명을 지정하기만 해도 해당 CDPATH에 포함된 디렉터리 중에서 이동할 곳을 검색한다. CDPATH는 쌍점(:)으로 구분해 여러 개의 PATH를 지정할 수 있다. cd에 지정한 인수의 디렉터리가 CDPATH로 지정된 여러 PATH에 있을 때는 먼저 지정된 PATH가 우선시 된다.

#### 4. 파라미터를 간접 참조한다.
eval은 파라미터를 간접 참조하여 인자가 된 변수로부터 값을 추출해내는 커맨드이다.
```
$ var1=abc
$ var2=var1
$ echo $human
men
$ echo $$human
$men
$ eval echo $$human
abc
```

#### 5. 지정된 커맨드를 스스로 실행한다.
exec은 fork 시스템콜을 사용하지 않고 지정된 커맨드를 스스로 실행한다. 보통 셀에서는 외부 커맨드를 사용할 경우 fork를 통해 별도의 자식 프로세스를 생성하고 커맨드가 실행된다.

exec내부 명령어를 이용하면 프로세스가 생성되지 않고 셸 자신이 지정된 커맨드로 치환되어 실행된다. exec을 사용하지 않는 경우 커맨드가 실행된 후에는 셸로 실행이 돌아가지만 사용한 경우에는 돌아가지 않는다.

#### 6. 표준 입력에서 1행 읽어들인다.
read는 입력한 문자열을 지정한 변수로 1행을 가져오는 커맨드이다.
키보드 입력 뿐 아니라 텍스트 파일을 불러올 수도 있다.

#### 7. 그 외의 내장 커맨드
| 커맨드 | 기능 |
|:--------:|:--------:|
| exit | 셀을 종료 |
| export | 셸 변수를 환경 변수로 함 |
| return | 셸 함수에서 빠져나옴 |
| unset | 지정된 셸 변수, 셸 함수를 삭제 |
| pwd | 현재 디렉터리 이름을 표시 |
| logout | 로그아웃 |
| kill | 지정된 프로세스를 중지함. 지정된 프로세스에 SIGTERM 신호가 전송됨|

# 3> 셸 스크립트의 문법
## 1. 셸 변수 선언
##### 1. 셸 스크립트 작성하기
셸 스크립트는 실행하려는 커맨드를 나열해놓은 텍스트이다.
파일명을 지정해줄 경우에는 시스템에 영향을 주지 않는 문자열이면 무엇이든 가능하다. 확장자는 `.sh`가 일반적이다. 보통 `cat > 파일명.sh` 혹은 `vi 파일명.sh`로 작성한다.

```
#!/bin/sh		//shebang(샤방), 이용할 셸 인터프리터를 지정한다.
echo "hello"	//echo를 이용ㅇ하여 표준 출력한다.
```
만약 인터프리터를 `#!/usr/bin/ruby`를 이용할 경우 오류가 난다. ruby에는 echo라는 메소드가 존재하지 않기 때문이다.

##### 2. `./`의 의미
`./`는 현재 디렉터리를 나타내는 표현이다. 사용자가 있는 현재 디렉터리는 환경 변수 pwd로 알 수 있으며 실행 가능한 파일이 들어 있는 디렉터리를 환경 변수 PATH를 통해 파악할 수 있다. 출력된 PATH에서 셸은 앞쪽 디렉터리에서부터 순서대로 커맨드를 검색한다.

만약 현재 텍스트를 작성하는 디렉터리 주소가 PATH에 등록되어있지 않으면 `command not found`가 실행된다.

## 2. 셸의 변수
##### 1. 셸 변수의 종류
| 변수 | 설명 |
|:--------:|:--------:|
| 셸 변수 | 구동 중인 셸, 셸 스크립트 내에서 이용할 수 있는 변수 |
| 환경 변수 | 여러 커맨드가 공유할 수 있는 변수<br>bash의 내장 커맨드 export로 변수를 생성/지정하면 환경 변수로 참조할 수 있게 됨 |
| 위치 파라미터 | 함수 등의 인수  참조에 사용하는 변수 |
| 특수 파라미터 | 인수 전체나 인수의 전체 개수 등을 나타내는 변수 |

##### 2. 셸 변수
변수 대입 시에는 `=`을 구분자로 쓰며 우변의 값을 좌변에 대입한다. 이때 해당 셸 내에서나 스크립트에서 일시적으로 값을 저장하고 참조하기 위한 변수를 셸 변수라고 한다. `$`을 붙이면 값 참조가 가능하다

```
$ VAL=16
$ echo VAL
VAL
$ echo $VAL
16
```

셸 변수 참조시 `*`등의 문자가 들어가면 경로 이름이 적용된다. 이런 문자들이 영향을 주지 않게 하기 위해서는 값에 `""`를 씌워주면 된다.

```
$ VAL="Hello *"
$ echo $VAL
Hello examples.desktop
$ echo "$VAL"
HELLO *
```

셸 변수는 set 커맨드를 사용해서 리스트로 표시할 수 있으며 `unset 변수명`을 통해서 삭제할 수 있다.

##### 3. 환경 변수
정의한 셸에서 구동된 커맨드에도 적용되는 변수를 환경 변수라고 한다. export로 셸 변수를 환경 변수로 바꿀 수 있다.

주요 환경 변수는 다음과 같다.

| 환경변수 | 설명 |
|:--------:|:--------:|
| PPID | Parent Process ID, 셸의 부모 프로세스 ID|
| PWID | cd 등으로 set 되어 있는 현재 작업 디렉터리 |
| OLDPWD | cd 등으로 set 되어 있는 하나 앞의 작업 디렉터리 |
| UID | 사용자 ID |
| BASH | bash의 절대 경로 |
| HISTFILE | 커맨드 이력 파일 |
| IFS | Internal Field Separator<br> 문자열 중간에서 단어를 구분 짓는 문자열을 지정한다.<br>기본값으로는 빈칸, 탭, 줄 바꿈이 설정되어 있다. |
| PATH | 커맨드 검색 경로<br>절대 경로로 커맨드를 지정하지 않는 경우, 이 목록에 들어 있는 경로를 바탕으로 실행 파일을 찾는다.<br>여러 개의 경로를 지정할 수 있으며 `:`로 이어서 기술한다. |
| HOME | 홈 디렉터리 경로 |

##### 4. 위치 파라미터
위치 파라미터는 스크립트나 셸 함수의 인수 참조에 사용된다. 만약 셀 스크립트 실행시 인수 값을 부여하지 않았다면 그 값을 가져올 때 위치 파라미터를 이용하게 된다. c언어의 `argc, *argv[]`와 비슷하다.
shift 연산을 통해 파라미터의 위치도 조절 가능하다.

##### 5. 특수 파라미터
스크립트 이름이나 인수, 프로세스 ID등을 참조하기 위한 변수로 이용한다.

| 특수 파라미터 | 설명 |
|:--------:|:--------:|
| $0 | 셸 스크립트 이름 참조 |
| $@ | 모든 인수 참조 |
| $* | 모든 인수를 스페이스(공백)로 구분 지은 문자열로 나열해 참조함 |
| $# | 인수 개수를 참조 |
| $? | 종료 상태 참조 |
| $! | 최근 생성한 프로세스 ID참조 |
| $$ | 자신의 프로세스 ID 참조 |
| $- | 셸의 옵션 플래그를 참조 |
| $_ | 직전에 실행한 커맨드의 가장 마지막 인수를 참조 |

## 3. if를 이용한 조건문
조건의 실행 결과가 참인지 거짓인지에 따라 그 후의 실행을 나누는 구문이다.
```
if 리스트1; then 리스트2; [elif 리스트3; then 리스트4;] ... [else 리스트5;] 랴
```
리스트1을 평가하여 그 결과가 참이면 리스트2를 처리한다. 리스트1을 거짓으로 통과해 elif가 있는 경우 리스트3을 평가해 참이면 리스트4를 처리한다. else는 모든 조건이 거짓일경우 처리된다.

## 4. while/for을 사용한 반복문(루프)
#### 1. while문을 이용한 커맨드의 반복(루프)
while을 통해 조건 범위를 지정하고 참일 경우 계속해서 커맨드를 실행한다.
```
while 리스트1; do 리스트2; done
```
이때 세미콜론을 붙이지 않으면 줄바꿈을 통해 기술해줘야한다.

#### 2. for문을 이용한 커맨드의 반복
1. 변수로 조건 지정하기
```
for 변수 [in 값 [값...]]; do 리스트; done
```
2. 산술식으로 조건 지정하기
```
for((식1; 식2; 식3;)) do 리스트; done
```
산술식으로 기술할 때에는 초깃값, 조건, 사후처리 순으로 기술되며 값이 조건을 만족하는 동안에 계속해서 실행된다.

#### 3. break로 루프 해제, continue로 계속 실행
break는 루프에서 빠져나올 때 사용하며 인수로는 빠져나올 루프의 수를 지정해준다.
continue는 현재 루프를 건너뛰고 다음 지점부터 계속 루프를 돌린다. return과 exit과는 비슷하지만 종료 범위가 명백히 다른 커맨드이므로 주의하자.

#### 4. 와일드카드를 이용한 반복
셸에서는 와일드카드 `*`를 사용해 여러 개의 파일을 다룰 수 있다.
```
for i in *.txt; do
	ls -lh $i
done
```
다음과 같이 txt 확장자를 가진 파일 하나씩 i에 대입해 커맨드를 실행한다.

## 5. 조건분기
#### case문
```
case 문자열 in 패턴1[|패턴2]...) 리스트;; esac
```
`|`를 넣음으로써 패턴을 여러 개 설정할 수 있으며 패턴이 참일 경우에 지정된 리스트를 처리한다.

#### switch문
X

## 6. 셸 함수
#### 1. function 문으로 함수를 이용한다.
자주 사용하는 부분을 함수처리하여 재사용한다. 다음과 같은 구조를 가진다.
```
function 함수명(){}
```

#### 2. shift를 이용해 커맨드 라인 인수를 처리한다.
앞쪽에서 언급했던 위치 파라미터를 이용한다. 여러개의 인수를 처리하고 싶을 때 사용한다.

#### 3. `'`와 `"`의 차이
* `'` : 텍스트를 셸이 해석하지 않게 만들어 특수문자 표시가 가능하다.
* `"` : 특수문자를 인식해서 그대로 표시되지 않는다.
* 셸에서 `\`를 사용하면 바로 뒤에 오는 특수문자를 무력화시킨다. (escape)

#### 4. 역따옴표` ` `
역따옴표로 감싼 텍스트는 커맨드로 실행되어 출력된다. `$()`와도 같다.

# 4> 셸의 설정파일
## 1. 로그인 셸
로그인 셀이란 0번째 인수의 첫 글자가 `-`이거나 `--login`으로 지정되어 있는 경우 구동하는 셸이다. 로그인 셸로 bash가 구동되면 읽어오는 파일의 순서는 다음과 같다.
1. /etc/profile
2. ~/.bash_profile
3. ~/.bash_login
4. ~/.profile

로그인 셀에서는 사용자 환경을 만들고자 일반 대화 셸과는 다른 파일을 불러오도록 되어있다.
로그아웃시에 홈 디렉터리의 `.bash_logout`을 읽어들인다.

## 2. 대화형 셸
대화형 셀이란 로그인 셀이 아닌 상태의 셸을 말한다. 이 경우 홈 디렉터리의 `.bashrc`를 불러온다.