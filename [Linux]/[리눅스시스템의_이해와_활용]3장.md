# 1 > 리눅스 커널 개요
## 1. 리눅스 커널이란?
리눅스 커널은 OS의 중추 역할이며, 다음 기능들을 가지고 있다.
##### 1. 디바이스 관리
하드웨어 입출력을 제어하는 소프트웨어를 이용해 각 장치들을 관리한다.

##### 2. 프로세스 관리
CPU의 프로세스 스케쥴링에 관여하며, 특정 사용자의 권한으로 실행되는 프로세스의 퍼미션을 확인 후 파일에 대해 읽기/쓰기를 실행하는데에 관여한다.

터미널에서 프로세스를 중지하기 위해서는 `Ctrl`+`c` 또는 `Ctrl`+`z` 입력을 하면 되는데 이때 사용자가 셸에서 프로세스로 신호를 보내게된다. 이벤트를 받은 프로세스는 이벤트의 종류에 따라서 처리를 실행한다.

시스템이 지원하는 신호는 `kill -l`로도 확인 가능하다.
```
$ kill -l
```

##### 3. 메모리 관리
프로그램 실행 시에 메모리에는 프로그램뿐만이 아니라 프로그램이 이용하는 데이터 영역도 동시에 메모리에 할당된다. 이때 메모리 영역을 분배하거나 이용이 끝난 메모리 영역 회수 등을 담당하는 것이 메모리 관리기능이다.

`가상 메모리`는 실제 메모리로의 접근에 대해 리눅스 커널을 덧씌운 가상 기억 영역을 프로그램에 제공하는 것이다. 이 영역은 메모리가 아닌 HDD같은 보조 기억 장치의 일부도 메모리처럼 보이게해서 더 큰 용량의 메모리를 쓸 수 있게한다. 이 영역을 `스왑영역`이라고 한다. 이때, 메모리에 있는 프로그램 전체 영역을 내보내는 것을 `Swap out`, 내보냈던 데이터를 메모리에 다시 가져오는 것을 `Swap in`이라고 한다.

##### 4. 시스템 콜 제공
**시스템 콜**이란 표준 출력이나 파일을 쓰는 write, 읽는 read, 프로세스를 fork하는 등의 기능을 가지고 있어서 사용자 프로그램에서 시스템에 액세스할 수 있도록 돕는다. 리눅스 커널에는 약 300개의 시스템 콜이 존재한다.

원래 시스템 콜을 이용하려면 인터럽트를 통해서 CPU에 대한 명령을 직접 어셈블러로 작성해야하지만, 간단히 이용할 수 있도록 C라이브러리 함수가 존재한다. 보통 리눅스 환경에서 C라이브러리 함수라는 것은 glibc를 가리킨다.

## 2. 시스템 부팅 절차
##### 1. BIOS
PC의 전원을 켜면 BIOS가 마더보드 상의 ROM에서 메모리로 복사되어 실행된다. BIOS는 입출력을 실행하는 소프트웨어로서 다음과 같은 기능들을 가진다.

* 마더보드에 접속된 장치의 초기화나 PC 부팅설정
* 부팅 순서 변경
* SATA RAID의 유/무효화 전환
* 접속 장치를 무효화
* POST(Power-On Self Test) : 각 하드웨어의 자가진단

##### 2. MBR
BIOS에서 POST가 실행되고 부트디바이스의 첫 섹터인 MBR(Master Boot Record)에 부팅 프로그램이 있는지 검사한다.
> MBR은 부팅 장치의 첫 512byte영역이다. 0 - 455byte는 부트로더, 466 - 509byte는 파티션 테이블, 510 - 511byte는 부트 시그니처가 들어간다.

파티션 테이블에는 스토리지의 파티션 구성 정보가 들어있으며, 이 영역에는 파티션정보를 4개까지 쓸 수 있다. 때문에 파티션은 4개까지만 분할하는게 알맞다. 이때 4개의 파티션은 `논리파티션`이라고 부른다.

부트시그니처에는 `0XAA55`가 들어가며, 없을경우 MBR로 인식되지 않는다.

만약 MBR에서 무사히 부트로더가 발견되면 이 프로그램을 메모리의 `0x7c00`에 쓴 다음 실행한다.

> BIOS > MBR > 부트 로더의 실행 순서
> 1. BIOS에서 HDD의 MBR읽어들임
> 2. 메모리에 부트로더 복사
> 3. BIOS에서 메모리의 `0x7c00`에 해당하는 부분을 실행

##### 3. 부트로더
부트로더는 커널을 실행하기 위한 프로그램이다. 부트 로더는 대용량 장치에서 부팅되는 커널을 찾아 메모리에 복사하여 커널의 세트업 루틴을 호출한다. MBR의 부트 로더는 대용량 장치에 있는 2차 부트 로더를 부팅시키고 그곳에서 리눅스 커널을 부팅한다.

##### 4. 리눅스 커널 파일의 구성
리눅스 커널 파일은 부트섹터, 셋업루틴, 압축해제루틴, 압축된 커널로 이루어져있다. 

셋업루틴은 하드웨어 초기화를 실시하며 메모리의 크기, 입력장치, VGA, HDD등의 정보를 얻고 커널 압축해제루틴을 호출한다.

압축이 풀리면 부트로더의 리눅스 커널 옵션 init=에 지정된 프로그램을 커널이 실행한다. 이때 특별한 지정이 되어있지 않은경우에는 `/sbin/init`을 실행한다.

# 2 > 리눅스에서 이용하는 부트 로더
## 1. GRUB
GRUB는 GNU Project의 하나로 개발된 부트로더이며, 작은 로드 프로그램을 적재해 부팅시에 메모리가 이를 읽어들이게 함으로써 커널의 위치를 파악하여 커널을 구동시킨다.

##### 1. GRUB의 두 가지 버전
`GRUB 1`와 `GRUB 2`가 유통되고 있으며, 2에서 변경된 큰 특징들은 다음과 같다.
* 설정 파일이 `menu.lst`에서 `grub.cfg`로 변경됨
* 파티션 번호 시작이 0에서 1로 변경됨

GRUB는 MBR의 512byte에 `stage1`의 로더를 먼저 구동한다. stage1 이후에 `stage 1.5` 또는 `stage 2`로더를 구동한다.
* `stage 1.5` : 파일 시스템을 해석하는 드라이버를 가지고 있다. 1에서 2로 직접 액세스 할 수 없을 때 사용한다.
* `stage 2` : 파일 시스템에 있는 GRUB의 설정 파일을 읽어들여서 사용자에게 부팅 후보를 표시한다.

##### 2. GRUB Shell
GRUB는 셸을 포함하고 있으며, `grub.cfg`로 부팅 목록을 표시하는데 셸 모드로 진입해 커널 파라미터의 추가나 변경, 초기 RAM 이미지 지정 변경 등의 작업을 수행할 수 있다. GRUB 셸은 시스템관리나 표준 커널에서는 지원 하지 않는 부품을 사용하는 PC 등의 문제 해결에 활용할 수 있다.

GRUB 셸은 부팅 시 부팅 목록이 표시되는 곳에서 `C`를 누르면 셸 모드로 진입한다.
주요 커맨드는 다음과 같다.

###### 1.set root
부팅 하려는 커널이 있는 파티션을 지정하는 경우 사용한다.
```
>set root=(hd0, msdos1)
>root (hd0,0)
```
`(hd0, msdos1)`는 부팅할 장치와 파티션을 인식하기 위한 문자이다. `root( `까지 입력 후 `Tab`을 누르면 자동완성 기능을 사용할 수 있다.

0과 1 등으로 인식된 장치명과 파티션 번호를 지정한다. GRUB Legacy에서는 0부터 카운트하며, 리눅스에서는 `/dev/sd[a-z][0-9]`형식을 사용한다.

###### 2.kernel/linux
구동할 커널을 지정해주는 커맨드이다. GRUB Legacy에서는 kernel, GRUB 2에서는 linux 커맨드를 이용한다.
```
kernel /boot/vmlinuz-2.6.18-1-686 root=/dev/sda1
linux /boot/vmlinuz-2.6.18-1-686 root=/dev/sda1
```

###### 3. initrd
초기의 RAM 디스크 이미지(메모리상에 일시적으로 적재되는 루트 파일 시스템)를 지정한다.
이 이미지를 이용해서 실제 루트 파일 시스템을 마운트하며 마찬가지로 `Tab`을 이용해 자동완성이 가능하다.

###### 4. boot
지금까지 입력한 커널 패스와 옵션 정보를 바탕으로 실제 커널을 부팅하는 커맨드이다. 부팅에 실패하면 Debian GNU/Linux는 관리자 비밀번호를 묻고 싱글 사용자 모드로 전환한다. 그 이후 재부팅되면 GRUB 셸에서 올바른 커널 경로와 옵션을 지정하면 시스템이 정상구동된다.

# 3 > 표준 입력/표준 출력/표준 에러 출력
프로세스가 생성되면 세 개의 파일 디스크립터(file descriptor)가 준비된다. 이는 데이터의 출입구이며, 키보드나 파일, 별도 프로세스의 입/출력을 프로세스에 또는 프로세스로 입/출력한다.

입/출력 설정은 변경할 수 있으며, 커맨드 혹은 파이프를 이용할 경우 가능하다.

## 1. 세 가지 표준 입출력
##### 1. 표준 입력
`stdin`, 프로세스에 데이터를 입력하는 스트림이다. 파일 혹은 그 외 프로세스의 출력 결과를 입력으로 받아들일 수도 있다. 특별한 입력 지정이 없으면 키보드가 그 역할을 한다.
##### 2. 표준 출력
`stdout`, 프로세스의 실행 결과나 실행 상태 보고를 출력하는 스트림이다. 단말기 디스플레이가 기본값이며, 실행 결과와 실행 상태 보고를 동시에 수행하는 프로세스라면 실행 결과만을 출력한다. 만약 실행 결과와 실행 상태 보고를 동시에 수행하는 프로세스라면 실행 결과만을 출력한다.
##### 3. 표준 에러 출력
`stderr`, 프로세스의 실행 상태나 에러 메시지를 출력하는 스트림이다. 단말기 디스플레이가 기본값이다.

## 2. 표준 입출력 표시
만약 에러가 발생하지 않을 경우, 표준 에러 출력은 출력하지 않지만 에러가 발생할경우 정상 작동한 곳까진 출력하도록 구현되어 있다.

##### 파일 디스크립터의 생성
프로세스가 만들어지면 해당 프로세스는 파일 디스크립터 0, 1, 2를 생성한다. 프로세스에는 이 세 개의 파일 디스크립터가 표준 입력과 표준 출력, 표준 에러 출력을 의미한다. 프로세스는 파일 디스크립터를 사용해 스트림을 변경할 수 있다.

# 4 > 파일 시스템
## 1. 파일 시스템이란?
파일 시스템이란 애플리케이션이 스토리지에 데이터를 읽고 쓸 때 이를 중개하는 커널 서비스 중 하나이다. 애플리케이션이 자신이나 사용자에 의해 데이터를 읽는 명령이 내려지면 시스템 콜을 이용해서 데이터를 불러온다. 이때 시스템 콜을 이용해 스토리지에서 데이터를 읽어들이는 과정에 파일 시스템이 들어가게 된다.

파일 시스템은 스토리지 안의 데이터를 간단하게 검색할 수 있는 알고리즘으로, 디렉터리 및 파일의 관리를 도우며 디스크 캐시를 이용한 비동기 쓰기로 처리속도를 향상시키고, 퍼미션을 통한 액세스 권한 관리 등을 수행해 멀티 사용자 시스템을 구현한다. 파일 시스템에 따라서는 파일 크기 및 파일 시스템 자체의 크기도 각각 다르다.

> ## 스토리지
> HDD나 SSD, USB메모리, SD카드, CF카드등이 해당된다. 용량이 메모리에 비해 훨씬 크고 가격이 싸지만, 읽기/쓰기 모두 느린편이다. 용량이 크기때문에 사용자가 스토리지를 관리하기 위한 어느정도의 구조가 필요해졌다.
> ## 메모리
> 전원이 꺼지면 내용이 휘발되어 영속적인 기록이 불가능한 기억 장치다. 하지만 스토리지에 비해 읽기/쓰기가 빠르다.

파일 시스템에는 리눅스의 경우 ext4(현재의 주류), ext2, ex3, reiserfs, XFS등이 있다.
DOS는 FAT16이나 FAT32, Windows의 VFAT이나 NTFS, CD-ROM이미지에 사용하는 ISO-9660, Mac OS X의 HFSX, 네트워크 파일 시스템 NFS등도 이용할 수 있다.

리눅스에서는 다음과 같이 이용할 수 있는 파일 시스템을 리스트로 표시할 수 있다.
```
$ cat /proc/filesystems
```