# 1 > 리눅스 커널 개요
## 1. 리눅스 커널이란?
리눅스 커널은 OS의 중추 역할이며, 다음 기능들을 가지고 있다.
##### 1. 디바이스 관리
하드웨어 입출력을 제어하는 소프트웨어를 이용해 각 장치들을 관리한다.

##### 2. 프로세스 관리
CPU의 프로세스 스케쥴링에 관여하며, 특정 사용자의 권한으로 실행되는 프로세스의 퍼미션을 확인 후 파일에 대해 읽기/쓰기를 실행하는데에 관여한다.

터미널에서 프로세스를 중지하기 위해서는 `Ctrl`+`c` 또는 `Ctrl`+`z` 입력을 하면 되는데 이때 사용자가 셸에서 프로세스로 신호를 보내게된다. 이벤트를 받은 프로세스는 이벤트의 종류에 따라서 처리를 실행한다.

시스템이 지원하는 신호는 `kill -l`로도 확인 가능하다.
```
$ kill -l
```

##### 3. 메모리 관리
프로그램 실행 시에 메모리에는 프로그램뿐만이 아니라 프로그램이 이용하는 데이터 영역도 동시에 메모리에 할당된다. 이때 메모리 영역을 분배하거나 이용이 끝난 메모리 영역 회수 등을 담당하는 것이 메모리 관리기능이다.

`가상 메모리`는 실제 메모리로의 접근에 대해 리눅스 커널을 덧씌운 가상 기억 영역을 프로그램에 제공하는 것이다. 이 영역은 메모리가 아닌 HDD같은 보조 기억 장치의 일부도 메모리처럼 보이게해서 더 큰 용량의 메모리를 쓸 수 있게한다. 이 영역을 `스왑영역`이라고 한다. 이때, 메모리에 있는 프로그램 전체 영역을 내보내는 것을 `Swap out`, 내보냈던 데이터를 메모리에 다시 가져오는 것을 `Swap in`이라고 한다.

##### 4. 시스템 콜 제공
**시스템 콜**이란 표준 출력이나 파일을 쓰는 write, 읽는 read, 프로세스를 fork하는 등의 기능을 가지고 있어서 사용자 프로그램에서 시스템에 액세스할 수 있도록 돕는다. 리눅스 커널에는 약 300개의 시스템 콜이 존재한다.

원래 시스템 콜을 이용하려면 인터럽트를 통해서 CPU에 대한 명령을 직접 어셈블러로 작성해야하지만, 간단히 이용할 수 있도록 C라이브러리 함수가 존재한다. 보통 리눅스 환경에서 C라이브러리 함수라는 것은 glibc를 가리킨다.

## 2. 시스템 부팅 절차
##### 1. BIOS
PC의 전원을 켜면 BIOS가 마더보드 상의 ROM에서 메모리로 복사되어 실행된다. BIOS는 입출력을 실행하는 소프트웨어로서 다음과 같은 기능들을 가진다.

* 마더보드에 접속된 장치의 초기화나 PC 부팅설정
* 부팅 순서 변경
* SATA RAID의 유/무효화 전환
* 접속 장치를 무효화
* POST(Power-On Self Test) : 각 하드웨어의 자가진단

##### 2. MBR
BIOS에서 POST가 실행되고 부트디바이스의 첫 섹터인 MBR(Master Boot Record)에 부팅 프로그램이 있는지 검사한다.
> MBR은 부팅 장치의 첫 512byte영역이다. 0 - 455byte는 부트로더, 466 - 509byte는 파티션 테이블, 510 - 511byte는 부트 시그니처가 들어간다.

파티션 테이블에는 스토리지의 파티션 구성 정보가 들어있으며, 이 영역에는 파티션정보를 4개까지 쓸 수 있다. 때문에 파티션은 4개까지만 분할하는게 알맞다. 이때 4개의 파티션은 `논리파티션`이라고 부른다.

부트시그니처에는 `0XAA55`가 들어가며, 없을경우 MBR로 인식되지 않는다.

만약 MBR에서 무사히 부트로더가 발견되면 이 프로그램을 메모리의 `0x7c00`에 쓴 다음 실행한다.

> BIOS > MBR > 부트 로더의 실행 순서
> 1. BIOS에서 HDD의 MBR읽어들임
> 2. 메모리에 부트로더 복사
> 3. BIOS에서 메모리의 `0x7c00`에 해당하는 부분을 실행

##### 3. 부트로더
부트로더는 커널을 실행하기 위한 프로그램이다. 부트 로더는 대용량 장치에서 부팅되는 커널을 찾아 메모리에 복사하여 커널의 세트업 루틴을 호출한다. MBR의 부트 로더는 대용량 장치에 있는 2차 부트 로더를 부팅시키고 그곳에서 리눅스 커널을 부팅한다.

##### 4. 리눅스 커널 파일의 구성
리눅스 커널 파일은 부트섹터, 셋업루틴, 압축해제루틴, 압축된 커널로 이루어져있다. 

셋업루틴은 하드웨어 초기화를 실시하며 메모리의 크기, 입력장치, VGA, HDD등의 정보를 얻고 커널 압축해제루틴을 호출한다.

압축이 풀리면 부트로더의 리눅스 커널 옵션 init=에 지정된 프로그램을 커널이 실행한다. 이때 특별한 지정이 되어있지 않은경우에는 `/sbin/init`을 실행한다.

# 2 > 리눅스에서 이용하는 부트 로더
## 1. GRUB
GRUB는 GNU Project의 하나로 개발된 부트로더이며, 작은 로드 프로그램을 적재해 부팅시에 메모리가 이를 읽어들이게 함으로써 커널의 위치를 파악하여 커널을 구동시킨다.

##### 1. GRUB의 두 가지 버전
`GRUB 1`와 `GRUB 2`가 유통되고 있으며, 2에서 변경된 큰 특징들은 다음과 같다.
* 설정 파일이 `menu.lst`에서 `grub.cfg`로 변경됨
* 파티션 번호 시작이 0에서 1로 변경됨

GRUB는 MBR의 512byte에 `stage1`의 로더를 먼저 구동한다. stage1 이후에 `stage 1.5` 또는 `stage 2`로더를 구동한다.
* `stage 1.5` : 파일 시스템을 해석하는 드라이버를 가지고 있다. 1에서 2로 직접 액세스 할 수 없을 때 사용한다.
* `stage 2` : 파일 시스템에 있는 GRUB의 설정 파일을 읽어들여서 사용자에게 부팅 후보를 표시한다.

##### 2. GRUB Shell
GRUB는 셸을 포함하고 있으며, `grub.cfg`로 부팅 목록을 표시하는데 셸 모드로 진입해 커널 파라미터의 추가나 변경, 초기 RAM 이미지 지정 변경 등의 작업을 수행할 수 있다. GRUB 셸은 시스템관리나 표준 커널에서는 지원 하지 않는 부품을 사용하는 PC 등의 문제 해결에 활용할 수 있다.

GRUB 셸은 부팅 시 부팅 목록이 표시되는 곳에서 `C`를 누르면 셸 모드로 진입한다.
주요 커맨드는 다음과 같다.

###### 1.set root
부팅 하려는 커널이 있는 파티션을 지정하는 경우 사용한다.
```
>set root=(hd0, msdos1)
>root (hd0,0)
```
`(hd0, msdos1)`는 부팅할 장치와 파티션을 인식하기 위한 문자이다. `root( `까지 입력 후 `Tab`을 누르면 자동완성 기능을 사용할 수 있다.

0과 1 등으로 인식된 장치명과 파티션 번호를 지정한다. GRUB Legacy에서는 0부터 카운트하며, 리눅스에서는 `/dev/sd[a-z][0-9]`형식을 사용한다.

###### 2.kernel/linux
구동할 커널을 지정해주는 커맨드이다. GRUB Legacy에서는 kernel, GRUB 2에서는 linux 커맨드를 이용한다.
```
kernel /boot/vmlinuz-2.6.18-1-686 root=/dev/sda1
linux /boot/vmlinuz-2.6.18-1-686 root=/dev/sda1
```

###### 3. initrd
초기의 RAM 디스크 이미지(메모리상에 일시적으로 적재되는 루트 파일 시스템)를 지정한다.
이 이미지를 이용해서 실제 루트 파일 시스템을 마운트하며 마찬가지로 `Tab`을 이용해 자동완성이 가능하다.

###### 4. boot
지금까지 입력한 커널 패스와 옵션 정보를 바탕으로 실제 커널을 부팅하는 커맨드이다. 부팅에 실패하면 Debian GNU/Linux는 관리자 비밀번호를 묻고 싱글 사용자 모드로 전환한다. 그 이후 재부팅되면 GRUB 셸에서 올바른 커널 경로와 옵션을 지정하면 시스템이 정상구동된다.

# 3 > 표준 입력/표준 출력/표준 에러 출력
프로세스가 생성되면 세 개의 파일 디스크립터(file descriptor)가 준비된다. 이는 데이터의 출입구이며, 키보드나 파일, 별도 프로세스의 입/출력을 프로세스에 또는 프로세스로 입/출력한다.

입/출력 설정은 변경할 수 있으며, 커맨드 혹은 파이프를 이용할 경우 가능하다.

## 1. 세 가지 표준 입출력
##### 1. 표준 입력
`stdin`, 프로세스에 데이터를 입력하는 스트림이다. 파일 혹은 그 외 프로세스의 출력 결과를 입력으로 받아들일 수도 있다. 특별한 입력 지정이 없으면 키보드가 그 역할을 한다.
##### 2. 표준 출력
`stdout`, 프로세스의 실행 결과나 실행 상태 보고를 출력하는 스트림이다. 단말기 디스플레이가 기본값이며, 실행 결과와 실행 상태 보고를 동시에 수행하는 프로세스라면 실행 결과만을 출력한다. 만약 실행 결과와 실행 상태 보고를 동시에 수행하는 프로세스라면 실행 결과만을 출력한다.
##### 3. 표준 에러 출력
`stderr`, 프로세스의 실행 상태나 에러 메시지를 출력하는 스트림이다. 단말기 디스플레이가 기본값이다.

## 2. 표준 입출력 표시
만약 에러가 발생하지 않을 경우, 표준 에러 출력은 출력하지 않지만 에러가 발생할경우 정상 작동한 곳까진 출력하도록 구현되어 있다.

##### 파일 디스크립터의 생성
프로세스가 만들어지면 해당 프로세스는 파일 디스크립터 0, 1, 2를 생성한다. 프로세스에는 이 세 개의 파일 디스크립터가 표준 입력과 표준 출력, 표준 에러 출력을 의미한다. 프로세스는 파일 디스크립터를 사용해 스트림을 변경할 수 있다.

# 4 > 파일 시스템
## 1. 파일 시스템이란?
파일 시스템이란 애플리케이션이 스토리지에 데이터를 읽고 쓸 때 이를 중개하는 커널 서비스 중 하나이다. 애플리케이션이 자신이나 사용자에 의해 데이터를 읽는 명령이 내려지면 시스템 콜을 이용해서 데이터를 불러온다. 이때 시스템 콜을 이용해 스토리지에서 데이터를 읽어들이는 과정에 파일 시스템이 들어가게 된다.

파일 시스템은 스토리지 안의 데이터를 간단하게 검색할 수 있는 알고리즘으로, 디렉터리 및 파일의 관리를 도우며 디스크 캐시를 이용한 비동기 쓰기로 처리속도를 향상시키고, 퍼미션을 통한 액세스 권한 관리 등을 수행해 멀티 사용자 시스템을 구현한다. 파일 시스템에 따라서는 파일 크기 및 파일 시스템 자체의 크기도 각각 다르다.

> ## 스토리지
> HDD나 SSD, USB메모리, SD카드, CF카드등이 해당된다. 용량이 메모리에 비해 훨씬 크고 가격이 싸지만, 읽기/쓰기 모두 느린편이다. 용량이 크기때문에 사용자가 스토리지를 관리하기 위한 어느정도의 구조가 필요해졌다.
> ## 메모리
> 전원이 꺼지면 내용이 휘발되어 영속적인 기록이 불가능한 기억 장치다. 하지만 스토리지에 비해 읽기/쓰기가 빠르다.

파일 시스템에는 리눅스의 경우 ext4(현재의 주류), ext2, ex3, reiserfs, XFS등이 있다.
DOS는 FAT16이나 FAT32, Windows의 VFAT이나 NTFS, CD-ROM이미지에 사용하는 ISO-9660, Mac OS X의 HFSX, 네트워크 파일 시스템 NFS등도 이용할 수 있다.

리눅스에서는 다음과 같이 이용할 수 있는 파일 시스템을 리스트로 표시할 수 있다.
```
$ cat /proc/filesystems
```

파일 시스템이 여러 방법이 있다고 해도 애플리케이션은 이들 파일 시스템의 차이를 따로 고려하지 않는다. 때문에 커널에서는 이 차이를 없애고 접근방법을 획일화하기 위해서 VFS(Virtual File System)을 제공하고 있다. 리눅스 커널은 시스템 콜로 파일이나 디렉터리에 대한 액세스 방법을 애플리케이션과 프로세스에 제공한다.

## 2. 파일 시스템의 구조
파일 시스템은 데이터의 관리, 효율성을 높이기 위해서 스스로의 상태를 파악하고 있어야한다. 데이터를 배치해 이용하는 영역, 미사용 영역, 파일 위치, 디렉터리 위치 등이 **메타데이터**로써 기록된다.

데이터를 좀 더 효율적으로 관리하기 위해서 어느 정도의 크기로 묶어서 한번에 처리한다. 이때의 용량을 **블록사이즈**라고 한다.

파일 시스템은 읽/쓰기에 고정길이의 블록 사이즈를 이용한다. 한 블록 내에서 사용하고 남은 용량은 공백이 된다. 때문에 만약 크기가 작은 데이터를 빈번하게 기록하는 시스템일 경우에는 블록 크기를 작게 설정해두는게 도움되지만, 너무 작게 설정해 둘 경우에는 스토리지에 대한 액세스에서 과부하가 일어날 수 있다.
> ext4에서는 최소 블록 사이즈가 1024byte로 설정되어 있다.
> 대부분의 리눅스 배포판에서는 ext3, ext4의 파일 시스템의 경우 한 블록이 4096byte로 설정되어있다.

VFS는 파일 시스템을 통괄하여 애플리케이션의 읽/쓰기를 중개한다. 이외에도 비동기 쓰기도 지원하며 파일 시스템에 대한 실제 쓰기의 일부를 메모리 버퍼 캐시에 기록하여 애플리케이션에는 쓰기를 완료했다고 보고함으로써 빠른것처럼 보이게 하는 처리도 가능하다.

##### > 저널 파일 시스템
스토리지에 쓰기를 하는 도중 충돌 등으로 쓰기를 완료하지 못한 상황이 발생했을 때에 대처하기 위해 사용한다.
애플리케이션에서 쓰기 명령이 내려오면 파일 시스템은 장애 발생에 대비해 데이터중 메타데이터를 저널이라고 부르는 영역에 기록한다.
그 뒤에 메타데이터와 데이터 본체를 합친 데이터를 스토리지에 기록한다. 이후에 저널에 썼던 메타 데이터를 삭제한다.
만약 이 과정을 완성하지 못하면 데이터가 갱신되지 않으므로 데이터는 보존될 수 있다.

## 3. 커널, 라이브러리, 애플리케이션
##### > 라이브러리?
다른 애플리케이션이 이용하는 함수가 들어 있다. 만약 라이브러리가 없을경우, 커널의 시스템 콜을 이용해 직접 코딩해야하며 라이브러리에 있는 함수는 재사용하기에도 용이하다. 프로그램 간에 공유할 수 있는 라이브러리를 **공유 라이브러리**라고 한다. 또한 프로그램을 컴파일한 후에 생기는 실행 가능한 파일도 공유할 수 있는 부분은 라이브러리로 만들 수 있다.

##### > 동적 프로그램?
라이브러리를 읽어들여 실행하는 프로그램을 동적 프로그램이라고 한다. 동적 프로그램인지 여부와 어떤 라이브러리를 사용하는지는 ldd(1)로 확인할 수 있다. 만약 어떤 프로그램이 설치후 동작하지 않는다면 이 명령어로 필요한 라이브러리를 알아볼 수 있다.
```
$ ldd /bin/ls
```

##### > 정적 프로그램?
실행 파일과는 별도로 공유 라이브러리를 사용하지 않는, 라이브러리를 가진 실행 파일을 정적 프로그램이라고 한다. 이 경우에는 ldd(1)로 파일 인수를 지정하면 **동적 실행 파일이 아닙니다**라는 한 행만 표시된 후 커맨드가 종료된다.
> ###### <?> busybox(1)
> **<!>** 여러개의 UNIX 도구를 이용하는 라이브러리까지 포함하여 하나의 바이너리 파일로 정리한 도구이다. `ldd /bin/busybox`로 정적 프로그램의 `ldd`실행결과를 알아볼 수 있다.

# 5 > 애플리케이션의 동작
리눅스에서 구동되는 커맨드 라인 애플리케이션의 대부분은 libc를 이용하며 libc는 커널의 시스템 콜을 이용해 디바이스에 액세스한다.
## 1. ls커맨드의 동작
ls(1)에 파일을 지정하면 해당 파일명이, 디렉터리를 지정하면 해당 디렉터리에 들어있는 파일명 리스트가, 옵션으로 -l을 붙이면 파일의 퍼미션, 소유권, 크기, 타임스탬프등의 상세 정보가 표시된다.

## 2. strace로 동작 추적
strace(1)은 인수로 지정한 커맨드가 사용하는 시스템 콜이나 신호를 표시해준다. 때문에 상세한 동작을 파악하거나 디버그 정보도 얻을 수 있다.

# 6 > UNIX 디바이스
UNIX 계열 OS는 프로그램에서 하드웨어에 액세스하기 쉽도록 사용자나 애플리케이션에서 하드웨어를 파일로 볼 수 있게 해 두었다.

## 1. 디바이스 파일의 종류
##### > 블록 디바이스
블록 디바이스란 거대한 데이터 블록을 주고받는 디바이스를 뜻한다. **버퍼**로 읽/쓰기 작업이 이루어지며 버퍼에 어느 정도의 블록 데이터가 쌓이면 이 버퍼의 내용이 디바이스에 데이터로 전송되고, 버퍼 안의 데이터는 삭제된다.

블록 디바이스는 데이터에 순차적으로 접근하지 않고 직접 데이터 위치를 찾아 접근하는 임의접근방식이다. 하드디스크나 CD드라이브, DVD, 메모리영역등이 블록 디바이스에 해당한다.

##### > 캐릭터 디바이스
캐릭터 디바이스란 byte 단위로 액세스하는 디바이스를 말한다. 캐릭터 디바이스는 ls(1)로 확인했을시에 앞글자가 c로 시작하며 블록 디바이스와는 다르게 버퍼를 거치지 않고 1byte씩 디바이스에 전송한다.

캐릭터 디바이스에는 PS/2나 USB마우스, 가상터미널, 사운드카드등이 해당된다.

## 2. 메이저 번호와 마이너 번호
디바이스는 메이저 번호와 마이너 번호로 구분되며, 메이저 번호는 디바이스를 구별하는 번호이고 마이너 번호는 해당 디바이스를 기기별로 구별하는 번호이다.