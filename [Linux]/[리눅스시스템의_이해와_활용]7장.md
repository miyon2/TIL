# 1 > syslogd
## 1. syslog?
대부분의 UNIX 시스템에서는 syslog라고 불리는 데몬이 실행되고 있고 커널, 시스템애플리케이션에서 메세지를 받는다. 또한 TCP/IP를 이용해 네트워크상의 원격 호스트의 syslog 데몬의 메세지도 기록할 수 있다. syslog는 RFC(Request for Comments)에 정의되어 있는 사양으로, 리눅스 서버뿐 아니라 라우터에서도 송신이 된다.

로그에는 날짜, 호스트, 송신자, 메시지가 한 행에 기록되고 기본적으로는 텍스트 파일로 저장되지만, PostgreSQL이나 MySQL등의 RDBMS에 저장하여 도구를 사용해 나중에 편집할 수도 있다.

## 2. syslog의 기록 내용
로그 각 부분의 내용은 다음과 같다.

| 항목 | 기록 내용 예 |
|:--------:|:--------:|
| 날짜 | Sep 27 06:55:01 |
| 호스트 이름 | prime |
| 태그 이름 | snmpd[1914]: |
| 메세지 | Connection from UDP:[192.168.1.7]:54235->[192.168.1.1] |

syslog는 클라이언트/서버 모델을 사용한다. syslogd는 로그를 기록하는 서버이며 UNIX 도메인 소켓 `/dev/log`를 준비해 구동한다. 클라이언트 측에서는 syslog(3)함수를 사용해 `/dev/log`경유로 메시지를 syslogd 서버에 송신한다.

한 서버 안에 서버와 클라이언트를 동시에 구성할 수도 있지만, 복수의 시스템 로그를 특정 호스트에서 실행되는 syslogd로 전송할 수도 있다. 이때 메세지 전송에는 UDP를 표준으로 사용한다. 단 여러개의 애플리케이션이 동시에 한 로그파일에 기록되면 기록을 찾을 때 매우 불편하기 때문에 syslog 데몬은 메시지를 송신하는 애플리케이션을 구분해 로그 파일을 각각 따로 기록한다.

syslog를 정의하는 RFC 3164 'The BSD syslog Protocol'에서는 PRI, HEADER, MSG 세가지를 정의하고 있다.

##### PRI
facility, priority를 나타내는 정수를 기술한다. syslog를 실제로 구현한 rsylog나 syslogd등의 애플리케이션은 이 부분은 생략된다. 기록할 경우에는 <수치> 형식으로 행 첫머리에 기록된다.

##### HEADER
날짜와 호스트 이름이 들어간다. 호스트의 이름 분석이 불가능할 때에는 호스트이름에 IP주소가 기록된다.

##### MSG
태그와 메세지가 들어가며 쌍점(:)으로 구분된다. 태그 이름에는 메시지를 작성한 프로그램명이 사용된다.

## 3. facility, priority
이 두가지를 조합하면 기록하는 로그 파일을 나눌 수 있다. 다음은 facility에서 이용하는 주요 값과 그 용도이다.

| facility | 용도 | 값 |
|:--------:|:--------:|:--------:|
| auth/security | 인증용 | 4/10/13/14 |
| authpriv | private 인증 메세지 |  |
| cron | cron 등 | 9/15 |
| daemon | facility 지정이 없는 데몬 | 3 |
| kern | 커널 | 0 |
| ipr | 프린터 | 6 |
| mail | 메일 서버 | 2 |
| news | 뉴스 서버 | 7 |
| syslog | syslog 데몬 | 5 |
| user | 사용자 프로세스용 | 1 |
| uucp | UUCP 용 | 8 |
| local[0-7] | 임의 용도(7개) | 16-23 |

다음은 priority에서 이용하는 주요 값과 그 용도이다.

| priority | 용도 | 값 |
|:--------:|:--------:|:--------:|
| debug | 디버그 레벨 | 7 |
| info | 정보 제공 레벨 | 6 |
| notice | 통보 레벨 | 5 |
| warning/warn | 주의 레벨 | 4 |
| error/err | 과실, 에러 레벨 | 3 |
| crit | 위험 레벨 | 2 |
| alert | 경보 레벨 | 1 |
| emerg/panic | 긴급 상황 | 0 |

facility와 priority는 각각 0-23, 0-7 수치가 설정되어 있으며, PRI가 생략되지 않는 실제 구현이면 `facility 수치X8 + priotiry 수치`가 기록된다.

priority는 수치가 낮을수록 우선도가 높다. priority 앞에 등호를 붙이면 그 우선도를 가진 메세지가 기록되며, 다른 모든 priority의 메세지는 무시된다. 또한 앞에 느낌표를 붙이면 지정한 우선도 메세지를 제외한 메세지가 기록된다.

액션 부분에는 기록할 로그 파일의 절대 경로, 전송할 원격 syslog 서버 정보, 파이프 |와 프로그램을 지정하여 다른 프로세스로 넘기도록 설정할 수 있다.

## 4. syslog 데몬 운용상의 주의점
* 각 서버 간 시간을 통일
로그를 로컬 syslog에서 원격 syslog 데몬에 전송할 때 로그를 보내는 쪽인 출발지 syslog 데몬에서 기록된 로그의 시각이 기록되어 원격 로그 서버로 전송된다. 직접 원격 syslog 서버에 메세지를 보낼 때에는 원격 syslog 서버의 시각이 기록된다. 그러므로 로그 서버에 기록을 의뢰할 때 서버는 ntp등을 이용ㅇ해 시각을 동기화하자.

* syslog의 신뢰도
로그를 원격 서버에 기록할 때 패킷 손실이 허용되는 UDP를 사용하게 되므로 로그 서버가 정지해있으면 로그 누락이 발생할 수 있다. 누락을 허용할 수 없는 시스템이라면 TCP를 이용하는 설정을 변경하거나 로컬 파일에 기록하여 이것을 원격 로그 서버에 전송하는 등 운용 방식을 고려하는게 좋다.

# 2 > cron
cron은 정해진 시간에 커맨드를 실행하는 데몬이며 다음과 같은 작업을 수행할 수 있다.
* 시스템의 로그 파일 용량이 지나치게 커지지 않게 파일을 치환해 압축하는 logrotate(8)을 실행
* 주기적으로 데이터베이스의 덤프를 가져와 백업에 이용함
* locate(1)용으로 시스템에 존재하는 파일 리스트를 생성함
* 휴식시간, 점심시간을 wall(1)을 사용해 사용자에게 알림

## 1. cron 데몬
cron은 데몬으로 시스템 부팅 시 기동된다. 시스템용 `/etc/crontab`, `/etc/cron.d` 아래의 각 사용자용 `/var/spool/crontab/`에 cron job 이라고 부르는 커맨드를 가진 파일을 읽어들여 지정된 시간에 실행한다. cron 실행 여부는 ps(1) 또는 service(8)로 확인할 수 있다.

## 2. cron 설정 파일
cron 데몬이 읽어오는 파일은 다음 3가지이다.
* `/etc/crontab` or `/etc/anacrontab`(centOS)
* `/etc/cron.d`
* `/var/spool/cron/crontab`

##### Ubuntu(vixie-cron)
cron 데몬이 읽어들이는 실행 파일의 포맷과 그 내용은 다음과 같다.
`[분 시 일 월 요일]	[실행 사용자명]	[커맨드와 옵션]`
cron 데몬의 시간 필드에 지정할 수 있는 값은 다음과 같다.

| 필드 | 값 |
|:--------:|:--------:|
| 분 | 0-59 |
| 시 | 0-23 |
| 일 | 1-31(31일이 안되면 그 달에 맞춤) |
| 월 | 1-12 |
| 요일 | 0-7(0과 7은 일요일) |

시간 지정은 책을 참고하자

##### CentOS(crond)
anacrontab의 설정 포맷은 다음과 같다.
`[간격] [지연시간(분]] [JOB-ID커맨드]`

간격은 그전 실행에서 얼마나 간격을 두고 다음 실행을 할 것인지를 나타내고 지연시간은 실제로 실행할 때까지 대기하는 시간을 지정하는 것이다. JOB-ID는 실행하는 job에 이름을 붙이는 것으로 로그파일 `/var/log/cron`기록에 JOB-ID를 붙인다.

##### RANDOM_DELAY & START_HOURS_RANGE
이 두가지는 지연시간에 랜덤으로 추가하는 시간의 최댓값과 정의한 시간이 시스템 구동 시간이 아닌 경우에 실행하지 않을것을 지시하는 변수이다.

CentOS에서는 cronie-anacron 패키지를 삭제해서 `/etc/crontab`을 유효화함으로써 분까지 시간을 지정해 주기적 처리를 실행할 수 있다.

## 3. 사용자별 cron 설정 파일
`/etc/crontab`과 `/etc/cron.d` 아래에는 시스템에서 이용하는 cron용 설정 파일을 두는데, 사용자별로 실행하는 cron을 설정할 수도 있다.

##### crontab으로 설정
1. 설정이 있는지 확인
```
$ crontab -l
```
2. 설정 파일 생성
```
$ crontab -e
```
3. 설정 파일 삭제하기
```
$ crontab -r
```

이 사용자용 cron 파일은 `/var/spool/cron`아래에 저장된다. 단 배포판에 따라서는 아래와 같이 저장위치가 달라질 수도 있다.
* CentOS : `/var/spool/cron/freelec`
* Ubuntu : `/var/spool/cron/crontabs/freelec`

##### 사용자별 접근 제어
crontab은 시스템에 계정이 있는 사용자라면 이용할 수 있는데, 사용자가 실수로 또는 고의로 부하를 높이는 처리를 실행하도록 지시할 때가 있어서 각 사용자 단위로 접근을 제어할 수 있게 만들어졌다.
기본적으로 존재하지 않는 `/etc/cron.allow`와 `/etc/cron.deny` 파일을 생성한다. 한 행마다 하나의 계정만 기술하면 리스트된 사용자의 crontab을 제어할 수 있다. 이때 두 파일 모두에 올라간 사용자가 있어도 allow된다.

## 4. 설정 확인
cron 설정 후에 동작을 확인하려면 실행하는 커맨드에 echo나 logger(1)을 부여해 해당 커맨드가 지정된 시각에 실행되었는지 디버그하면 된다.

## 5. 로그 로테이션
##### <?> 로그 로테이션이란?
커널이나 각 데몬의 메세지를 계속 기록하게 되면 로그 파일 크기가 커져 파일 시스템의 파일 용량 상한에 도달해 메세지를 기록할 수 없게 된다. 이를 방지하기 위한 것이 logrotate(8)이다.

logrotate(8)은 cron 경유로 구동되며 지정된 로그 파일을 이동, 압축하고 새로운 파일을 생성하며 필요할 경우 데몬을 재구동한다.

##### <!> 로그 로테이션 처리 순서
1. cron(8)이 `/etc/cron.daily/logrotate`를 읽어들임
2. logrotate(8)가 `/etc/logrotate.conf`를 설정 파일로써 실행하여 logrotate.conf에 지정된 로그 파일을 처리함
3. `/etc/logrotate.d/`아래의 파일을 읽어들여 지정된 로그 파일을 처리함

설정 파일은 `/etc/logrotate.conf`에서 로테이션 기간, 새로운 로그 파일 생성방법 지정, 압축 지정 등 다양한 설정이 가능하다. 또한 `/etc/logrotate.d`아래에 데몬이나 애플리케이션별 로그 파일 지정과 처리 방법을 기술할 수 있다.

직접 만든 애플리케이션이나 배포판 패키지 관리 시스템 이외에 데몬이 생성하는 로그파일의 경우 이미 설치된 logrotate(8)의 관리 대상에 포함되어 있는지 확실히 확인하도록 하자

# 3 > anacron
## 1. anacron?
시스템에서는 가동 시간이 아닌 시간에 cron을 지정해 두면 프로그램이 실행되지 않는다. 이와 같은 비 연속적인 시스템 가동을 위한 cron으로 anacron이라고 한다. 배포판에 따라 실행 방법이 다르다.

## 2. 실행(`/etc/anacrontab`)
anacron의 실행 시간이나 커맨드를 지정하는 포맷은 **주기**, **지연**, **job ID**, **커맨드**이다. 주기는 실행할 간격을, 지연은 anacron이 구동되고 수개월 경과한 경우 여러 개의 프로세스가 동시에 실행되는것을 막고자 지정한 분 만큼 실행을 늦추는것이다. job ID는 특정 이름을 붙여서 각 job 실행 후에 실행일을 기록하는 `/var/spool/anacron`에 저장되는 파일명으로 사용된다. 커맨드에는 실행하는 커맨드를 기술한다.

anacron은 주기가 되면 지정된 커맨드를 실행하고, 실행 후 기록 파일 job ID를 변경한다. 이후 지연시간에 따라 실행 허가 시간을 지정한다.

# 4 > at
## 1. at?
cron은 정해진 시간에 같은 처리를 실행하는 시스템이지만, 시스템에 로그인하지 않고 한 번만 자동으로 정해진 시간에 커맨드를 실행할 때에는 at을 사용한다.
* at(1) : job의 등록, 삭제, 리스트 표시
* atd(1) : 등록된 job tlfgod

## 2. job queue(작업 큐)의 확인과 출력
작업 큐 확인에는 atq(1)를 사용한다. 이때 queue ID, 실행 일시, 실행 우선순위, 실행 사용자명 순으로 표시된다. 실행 우선순위는 at(1)의 -q로 알파벳 a-z, A-Z사이의 한 문자로 지정하며 기본값으로는 a가 지정되어 있다. 뒤로갈수록 우선순위는 낮아진다.