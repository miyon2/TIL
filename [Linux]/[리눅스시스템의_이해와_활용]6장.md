# 1 > SSH 서버
## 1. SSH란?
SSH란 Secure SHell로 통신 경로를 암호화하는 SSH 프로토콜을 사용하여 안전한 원격셸을 제공하는 서비스를 가리킨다. telnet(1)과 rsh(1)은 통신 경로를 암호화하지 않아서 로그인 사용자명, 비밀번호, 패킷이 암호화되지 않고 노출되어 이동한다. 때문에 암호화 대책으로 SSH를 일반적으로 이용하게 되었다.

> SSH프로토콜도 version1과 2가 있는데 1은 프로토콜에 취약성이 있으므로 2를 사용해야한다.

사용자 인증에는 비밀번호뿐 아니라 공개키를 이용한 공개키 인증이나 원 타임 비밀번호를 이용할 수 있다. 
* 공개키 인증 : 공개키-비밀키 쌍을 서버에 두고 해당 페어를 증명하여 인증받는다.
* 원 타임 비밀번호 : 한 번만 사용하는 비밀번호로 인증받는다.

SSH 프로토콜은 원격 셸이나 파일전송뿐 아니라 해당 세션에 다른 애플리케이션의 통신을 캡슐화할 수 있다. 때문에 평문(plain text)으로 통신하는 애플리케이션도 암호화 통신이 가능해진다.(SSH포트포워드) 이를 통해 VPN을 구축할 수 있다.

SSH는 서비스를 제공하는 SSH 서버와 SSH 서버에 로그인하는 SSH클라이언트로 구성된다.

## 2. SSH 데몬
SSH 서버를 구동하려면 sshd라는 데몬 프로세스를 실행한다. sshd(8)을 구동하면 22/TCP로 SSH클라이언트의 접속을 기다리게 되어있다. 클라이언트에서 접속이 오면 이용하는 SSH 프로토콜 버전 교환을 시작으로 통신한다.

동작 과정은 다음과 같다.

1. 접속 요구
2. SSH 프로토콜 버전 교환
3. DH 키 교환을 거쳐 세션 키를 취득
4. 호스트 키/사용자 키 교환
5. 인증
6. 세션 개시
7. 셸 커맨드 실행
8. 세션 종료

##### > Diffie-Hellman 키 교환(DH 키 교환)
클라이언트와 서버의 사전 키 교환 없이 암호화되어 있지 않은 경로에서 암호 키를 공유하는 암호 프로토콜이다.

##### > 키 교환
SSH 프로토콜 통신을 체결하면 DH 키 교환을 통해 세션 키를 취득하고 서버의 호스트 키와 클라이언트의 사용자 키를 서로 교환한다. 이후 동작은 다음과 같다.

* 클라이언트에 SSH 서버의 호스트 키가 등록된 경우 : 문제 X
* 클라이언트에 SSH 서버의 호스트 키가 등록되어 있지 않은 경우 : SSH 서버 호스트 키의 핑거프린트(finger print)를 표시하여 등록 확인을 표시함.
* 클라이언트에 등록된 SSH 서버의 호스트 키와 다른 경우 : Man-in-the-middle 공격의 가능성이 있다는 경고를 표시

##### > 암호화 통신 개시
서버와 클라이언트의 인증에 들어간다. 비밀번호 인증/공개키 인증을 이용해 계정을 사용할지 판단한다.
인증 통과시에 셸 구동, 커맨드 실행, X 클라이언트 전송 등을 실행해 세션을 개시한다.

세션이 실행되면 SSH 클라이언트와 셸 등과의 통신으로 넘어간다. 통신이 끝나면 서버는 세션 종료를 클라이언트 측에 통보하고 접속을 종료한다.

## 3. SSH 데몬 설정 파일
sshd(8)이 이용하는 `/etc/ssh`아래에 정리되어 있다.
* moduli : DH 키 교환에 사용하는 데이터
* sshd_config(!=ssh_config) : SSH 데몬이 참조하는 설정 파일
* ssh_host_*.key{.pub} : SSH 서버에서 가지는 SSH 호스트 키
* ssh_config : SSH 클라이언트가 참조하는 기본 설정 파일

##### ssdh_config의 예(Ubuntu)
authorized_keys 파일에는 한 행에 하나의 공개키를 기술한다. ssh-copy-id(1)등으로 공개키를 등록하면 괜찮지만, less(1)나 lv(1)등의 페이저로 공개키를 표시한 후 마우스로 복사해 붙여 넣는 방식으로 vi(1)나 emacs(1)등에 붙여 넣거나 저장하면 줄 바꿈이 들어가므로 하나의 공개키가 여러 행에 걸쳐 표시되게 된다. 이때의 공개키는 유효하지 않다. 때문에 에디터로 편집할 떄는 cat(1)로 공개키를 표시하고 복붙하는게 좋다.

authorized_keys 파일은 공백으로 구분되고 다음과 같이 구성되어있다.(SSH 프로토콜 version2)
[`옵션` `키 종류` `BASE64로 인코딩된 키` `키의 코멘트`]

옵션은 'from'을 이용하여 접근을 시도하는 IP주소의 제한, 호스트확인이 가능하며 'command'로는 실행하는 커맨드 제한을 설정할 수 있지만 비워도 상관없다.

AuthorizedKeysFile 설정에서 사용자의 공개키를 `/etc/ssh/authorized_keys`라는 디렉터리에 넣어둘 때 사용자명은 `%u`로 치환된다.

challenge response(질의/응답)인증의 순서는 다음과 같다.
1. 클라이언트가 서버에 접속을 요구
2. 서버가 랜덤으로 challenge라고 불리는 문자열을 클라이언트에 전송
3. 클라이언트가 challenge와 비밀번호를 바탕으로 response를 작성하여 서버에 전송
4. 서버가 자신이 가진 비밀번호와 challenge로 생성한 문자열과 클라이언트에서 보내온 response를 비교
5. 문자열과 response가 같으면 인증 성공
이 모든 과정에는 평문 비밀번호가 오가지 않는다.

SSH는 원격 호스트에 텍스트로 로그인해 커맨드를 사용하는것이 아닌, 서버의 애플리케이션을 클라이언트의 X서버로 전송하는것이다. X11 전송을 허가한 SSH 서버에 로그인해 X애플리케이션을 전송시키려면 클라이언트 로그인 시에 -X 옵션을 추가해야 한다.

X 전송 기능을 이용하면 SSH의 X11 전송을 무효화해도 전송할 수 있지만, 위험하므로 가능하면 허가하지 않는것이 좋다.

##### ssdh_config의 예(CentOS)
**<?> SSH 포트 포워드**
SSH 포트 포워드는 TCP 전송을 통하여 안전하지 않은 TCP/IP 프로토콜을 캡슐화함으로써 암호화된 TCP/IP 프로토콜로 안전하게 경로를 이용할 수 있게 된다. 이때 프로그램이 암호화에 이용할 주소화 포트가 필요하다.

만약 암호화 되지 않은 경로가 있다면, SSH TCP 전송을 통해서 SSH 서버를 거치는 경로를 만들 수 있다. 이때 클라이언트 실행서버부터 SSH서버까지의 경로는 암호화되어있으며, SSH서버부터 도착서버까지는 암호화 되어있지 않다. SSH TCP 전송을 통해 암호화한 경로를 만들기 위해서는 다음과 같이 실행하면 된다.

```
$ ssh -L 암호화할포트:도착지서버:도착지서버포트@SSH서버
```

이후에 클라이언트에서 접속할 도착지 서버로 localhost, 포트를 지정하면 메일을 수신할 수 있다. 즉 방화벽을 넘어 포워드를 할 수도 있다.

## 4. SSH 클라이언트 설정
SSH 클라이언트는 개발 서버나 설치 서버 로그인 등에 많이 이용하는 도구중 하나이다. SSH를 사용할 때 긴 커맨드나 호스트 이름을 입력하거나 공개키 인증 패스 문구를 입력하는건 번거롭기 때문에 이를 편리하게 해줄 설정 파일(OpenSSH)을 만들 수 있다.

SSH 클라이언트의 옵션은 다음 순서로 읽어들인다.
1. ssh 커맨드 라인 옵션
2. 사용자별 옵션(`~/.ssh/config`)
3. 시스템 옵션(`/etc/ssh/ssh_config`)
4. ssh 커맨드 기본 파라미터

# 2 > 네트워크 파일 시스템
## 1. NFS(Network File System)
NFS는 서버 자신이 가진 스토리지의 파일 시스템을 네트워크 경유로 원격 호스트에 제공하기 위한 프로토콜이다.
