# 1 > SSH 서버
## 1. SSH란?
SSH란 Secure SHell로 통신 경로를 암호화하는 SSH 프로토콜을 사용하여 안전한 원격셸을 제공하는 서비스를 가리킨다. telnet(1)과 rsh(1)은 통신 경로를 암호화하지 않아서 로그인 사용자명, 비밀번호, 패킷이 암호화되지 않고 노출되어 이동한다. 때문에 암호화 대책으로 SSH를 일반적으로 이용하게 되었다.

> SSH프로토콜도 version1과 2가 있는데 1은 프로토콜에 취약성이 있으므로 2를 사용해야한다.

사용자 인증에는 비밀번호뿐 아니라 공개키를 이용한 공개키 인증이나 원 타임 비밀번호를 이용할 수 있다. 
* 공개키 인증 : 공개키-비밀키 쌍을 서버에 두고 해당 페어를 증명하여 인증받는다.
* 원 타임 비밀번호 : 한 번만 사용하는 비밀번호로 인증받는다.

SSH 프로토콜은 원격 셸이나 파일전송뿐 아니라 해당 세션에 다른 애플리케이션의 통신을 캡슐화할 수 있다. 때문에 평문(plain text)으로 통신하는 애플리케이션도 암호화 통신이 가능해진다.(SSH포트포워드) 이를 통해 VPN을 구축할 수 있다.

SSH는 서비스를 제공하는 SSH 서버와 SSH 서버에 로그인하는 SSH클라이언트로 구성된다.

## 2. SSH 데몬
SSH 서버를 구동하려면 sshd라는 데몬 프로세스를 실행한다. sshd(8)을 구동하면 22/TCP로 SSH클라이언트의 접속을 기다리게 되어있다. 클라이언트에서 접속이 오면 이용하는 SSH 프로토콜 버전 교환을 시작으로 통신한다.

동작 과정은 다음과 같다.

1. 접속 요구
2. SSH 프로토콜 버전 교환
3. DH 키 교환을 거쳐 세션 키를 취득
4. 호스트 키/사용자 키 교환
5. 인증
6. 세션 개시
7. 셸 커맨드 실행
8. 세션 종료

##### > Diffie-Hellman 키 교환(DH 키 교환)
클라이언트와 서버의 사전 키 교환 없이 암호화되어 있지 않은 경로에서 암호 키를 공유하는 암호 프로토콜이다.

##### > 키 교환
SSH 프로토콜 통신을 체결하면 DH 키 교환을 통해 세션 키를 취득하고 서버의 호스트 키와 클라이언트의 사용자 키를 서로 교환한다. 이후 동작은 다음과 같다.

* 클라이언트에 SSH 서버의 호스트 키가 등록된 경우 : 문제 X
* 클라이언트에 SSH 서버의 호스트 키가 등록되어 있지 않은 경우 : SSH 서버 호스트 키의 핑거프린트(finger print)를 표시하여 등록 확인을 표시함.
* 클라이언트에 등록된 SSH 서버의 호스트 키와 다른 경우 : Man-in-the-middle 공격의 가능성이 있다는 경고를 표시

##### > 암호화 통신 개시
서버와 클라이언트의 인증에 들어간다. 비밀번호 인증/공개키 인증을 이용해 계정을 사용할지 판단한다.
인증 통과시에 셸 구동, 커맨드 실행, X 클라이언트 전송 등을 실행해 세션을 개시한다.

세션이 실행되면 SSH 클라이언트와 셸 등과의 통신으로 넘어간다. 통신이 끝나면 서버는 세션 종료를 클라이언트 측에 통보하고 접속을 종료한다.

## 3. SSH 데몬 설정 파일
sshd(8)이 이용하는 `/etc/ssh`아래에 정리되어 있다.
* moduli : DH 키 교환에 사용하는 데이터
* sshd_config(!=ssh_config) : SSH 데몬이 참조하는 설정 파일
* ssh_host_*.key{.pub} : SSH 서버에서 가지는 SSH 호스트 키
* ssh_config : SSH 클라이언트가 참조하는 기본 설정 파일

##### ssdh_config의 예(Ubuntu)
authorized_keys 파일에는 한 행에 하나의 공개키를 기술한다. ssh-copy-id(1)등으로 공개키를 등록하면 괜찮지만, less(1)나 lv(1)등의 페이저로 공개키를 표시한 후 마우스로 복사해 붙여 넣는 방식으로 vi(1)나 emacs(1)등에 붙여 넣거나 저장하면 줄 바꿈이 들어가므로 하나의 공개키가 여러 행에 걸쳐 표시되게 된다. 이때의 공개키는 유효하지 않다. 때문에 에디터로 편집할 떄는 cat(1)로 공개키를 표시하고 복붙하는게 좋다.

authorized_keys 파일은 공백으로 구분되고 다음과 같이 구성되어있다.(SSH 프로토콜 version2)
[`옵션` `키 종류` `BASE64로 인코딩된 키` `키의 코멘트`]

옵션은 'from'을 이용하여 접근을 시도하는 IP주소의 제한, 호스트확인이 가능하며 'command'로는 실행하는 커맨드 제한을 설정할 수 있지만 비워도 상관없다.

AuthorizedKeysFile 설정에서 사용자의 공개키를 `/etc/ssh/authorized_keys`라는 디렉터리에 넣어둘 때 사용자명은 `%u`로 치환된다.

challenge response(질의/응답)인증의 순서는 다음과 같다.
1. 클라이언트가 서버에 접속을 요구
2. 서버가 랜덤으로 challenge라고 불리는 문자열을 클라이언트에 전송
3. 클라이언트가 challenge와 비밀번호를 바탕으로 response를 작성하여 서버에 전송
4. 서버가 자신이 가진 비밀번호와 challenge로 생성한 문자열과 클라이언트에서 보내온 response를 비교
5. 문자열과 response가 같으면 인증 성공
이 모든 과정에는 평문 비밀번호가 오가지 않는다.

SSH는 원격 호스트에 텍스트로 로그인해 커맨드를 사용하는것이 아닌, 서버의 애플리케이션을 클라이언트의 X서버로 전송하는것이다. X11 전송을 허가한 SSH 서버에 로그인해 X애플리케이션을 전송시키려면 클라이언트 로그인 시에 -X 옵션을 추가해야 한다.

X 전송 기능을 이용하면 SSH의 X11 전송을 무효화해도 전송할 수 있지만, 위험하므로 가능하면 허가하지 않는것이 좋다.

##### ssdh_config의 예(CentOS)
**<?> SSH 포트 포워드**
SSH 포트 포워드는 TCP 전송을 통하여 안전하지 않은 TCP/IP 프로토콜을 캡슐화함으로써 암호화된 TCP/IP 프로토콜로 안전하게 경로를 이용할 수 있게 된다. 이때 프로그램이 암호화에 이용할 주소화 포트가 필요하다.

만약 암호화 되지 않은 경로가 있다면, SSH TCP 전송을 통해서 SSH 서버를 거치는 경로를 만들 수 있다. 이때 클라이언트 실행서버부터 SSH서버까지의 경로는 암호화되어있으며, SSH서버부터 도착서버까지는 암호화 되어있지 않다. SSH TCP 전송을 통해 암호화한 경로를 만들기 위해서는 다음과 같이 실행하면 된다.

```
$ ssh -L 암호화할포트:도착지서버:도착지서버포트@SSH서버
```

이후에 클라이언트에서 접속할 도착지 서버로 localhost, 포트를 지정하면 메일을 수신할 수 있다. 즉 방화벽을 넘어 포워드를 할 수도 있다.

## 4. SSH 클라이언트 설정
SSH 클라이언트는 개발 서버나 설치 서버 로그인 등에 많이 이용하는 도구중 하나이다. SSH를 사용할 때 긴 커맨드나 호스트 이름을 입력하거나 공개키 인증 패스 문구를 입력하는건 번거롭기 때문에 이를 편리하게 해줄 설정 파일(OpenSSH)을 만들 수 있다.

SSH 클라이언트의 옵션은 다음 순서로 읽어들인다.
1. ssh 커맨드 라인 옵션
2. 사용자별 옵션(`~/.ssh/config`)
3. 시스템 옵션(`/etc/ssh/ssh_config`)
4. ssh 커맨드 기본 파라미터

# 2 > 네트워크 파일 시스템
## 1. NFS(Network File System)
NFS는 서버 자신이 가진 스토리지의 파일 시스템을 네트워크 경유로 원격 호스트에 제공하기 위한 프로토콜이다.

NFS 서버는 원격 호스트에 제공하는 스토리지와 접근 제어에 사용하는 설정 파일의 조정이 필요하다. NFS 클라이언트는 수동으로 마운트할 때에는 mount(8), 자동으로 하는 경우에는 `/etc/fstab`설정이 필요하다.

NFS 서버는 Debian의 경우 nfs-server패키지, Red Hat 계열은 nfs-utils 패키지를 이용해 구축하면 된다. 설정 파일은 `/etc/exports`뿐이다. 이곳에 공유 디렉터리, 공유할 곳, 옵션을 `()`로 기술한다.

공유할 호스트는 FQDN/IP 주소로 지정한다. 이때 와일드카드 기호를 사용할 수 있으며, 호스트 대신 `gss/krb5`, `gss/krb5i`, `gss/krb5p`를 사용하면 GSS-API와 Kerberos를 이용한 인증으로 접근을 정의할수도 있다.

NFS 서버에 시스템을 이용하는 각 사용자의 홈 디렉터리르 만들어두면 각 클라이언트는 부팅후에 서버에 접속해 홈 디렉터리를 마운트한다. 이 때의 클라이언트에서의 홈 디렉터리 퍼미션은 사용자 ID를 통해 이뤄진다. 클라이언트의 사용자 아이디에 해당하는 NFS의 디렉터리만 읽기 쓰기가 가능하다.

##### 옵션
옵션에는 일반옵션, 사용자 맵 옵션이 있다. 기본은 ro(읽기전용 fs), wdelay(NFS 서버에 대한 쓰기지연으로 퍼포먼스 향상처럼 보임), root_squash(root로 접속하면 NFS서버에서 일반 사용자 취급해 악성 파일이 생기는 것을 방지)가 설정되어 있다. 그 외의 주요 옵션은 다음과 같다.

| 옵션 | 설명 |
|:--------:|:--------:|
| rw | 읽고 쓰기 가능 |
| subtree_check | 서브 디렉터리만 공유되는 경우, 그 상위 디렉터리가 공유하는지 확인함 |
| no_subtree_check | subtree_check을 실시하지 않도록 설정함(퍼포먼스 향상) |
| async | 지연 쓰기 유효, 비동기로 디스크에 쓰기(기본설정) |
| sync | 지연 쓰기 무효, 바로 쓰기 |
| no_root_squash | 클라이언트에서 root 사용자가 접속하면 root 권한으로 접근을 허가 |
| all_squash | root와 이외 사용자 모두 nobody 사용자로 매핑함 |
| secure | 1024이하 포트번호로 접근이 오면 받지 않음 |
| insecure | 1024이하 포트번호로 접근이 와도 받아들임 |

## 2. Samba
Samba는 SMB/CIFS 프로토콜을 사용해 Windows와 Linux간의 파일공유, 프린터공유, 인증, 이름분석 등의 기능을 제공한다.

* SMB(Server Message Block) : LAN 상에서 파일 공유나 프린터 공유를 구현하는 프로토콜
* CIFS(Common Internet File System) : SMB의 사양을 공개, 확장한 프로토콜

##### smb.conf
Samba의 설정 파일이다. 설정 파일에서는 섹션과 섹션에 속하는 파라미터 그리고 해당 파라미터 값을 =로 대입하여 설정한다. 섹션에는 [global], [homes], [printers]등이 있으며 다음 섹션의 정의까지가 그 섹션에 속하는 파라미터가 된다.

## 3. WebDAV(Web-based Distributed Authoring and Versioning)
WebDAV는 여러명이 원격 웹 서버의 파일 편집이나 관리를 수행할 수 있도록 확장한 HTTP 프로토콜이다. 리눅스에서 이용하는 웹서버 Apache에 mod_dav 모듈이 표준 탑재되어 있으므로 이를 설정하면 파일을 공유할 수 있다.

`/etc/apache2/mod-available/dav_fs.conf`를 확인하면 한 행만 기술되어있다. 이 APACH_LOCK_DIR 변수는 `/etc/apache2/envvars`에 정의되어 `/var/lock/apache2`가 들어있다. 때문에 lock 파일은 `/var/lock/apache2/DAVLock`이 되도록 설정해 기본 값인 DAVLockDB 행을 그대로 카피하는것이 좋다.

##### WebDAV 설정
> chown : 파일의 소유자 또는 소유 그룹을 변경하기 위한 커맨드

Digest 인증 파일은 htdigest(1)로 생성한다. 또한 그룹 파일은 [그룹명:사용자명1 사용자명2]과 같은 식으로 작성하면 복수 사용자를 그룹으로 취급해 접근을 제어할 수 있다.

##### WebDAV 접곤
Nautilus에서 인증을 통과하면 새 창에서 WebDAV 디렉터리의 리스트가 표시된다. 또한 커맨드라인으로 접근할 수 있는 cadaver(1)도 있다.

WebDAV에서는 디렉터리를 가리켜 Collection이라고 부른다.

# 3 > Apache(httpd 서버)
## 1. Apache?
리눅스 배포판의 httpd 서버 중 대표적인 것이 Apache HTTP Server다. Apache는 모듈로써 다양한 기능을 추가/설정할 수 있다.

## 2. 설정 파일
설정 파일은 텍스트 파일로 기본 틀이 되는 `httpd.conf`를 생성한다. `httpd.conf`의 안에는 공백으로 구분하여 변수명과 값을 기술하는 **지시어(디렉티브)**라는 설명문을 기술한다. Include, Alias등이 그러하다. 지시어는 <Directory>~</Directory>와 같이 작성해 유효 범위를 지정해준다.

## 3. 설정 파일 - CentOS
메인 설정 파일은 httpd.conf, 가상호스트는 Include 지시어로 지정된 `/etc/httpd/conf.d/`아래의 `*.conf`확장자를 가진 텍스트 파일로 지정한다. 이 디렉터리에는 디폴트로 `welcome.conf`가 유효하게 읽히는 파일로 존재한다.

> #### MPM(Multi Processing Module)
MPM은 클라이언트의 요청 처리 방법을 모듈로 구분한 것으로 다음과 같은 것들이 있다.
* event : worker를 멀티 프로세스 + 멀티 스레드로 구성한 MPM
* mpm_netware : novel Netware에 최적화된 MPM
* mpmt_os2 : OS2에 최적화된 멀티 프로세스 멀티 스레드 MPM
* prefork : 미리 fork하여 프로세스를 생성, 대기하는 MPM
* mpm_winnt : Windows NT에 최적화된 멀티 프로세스 MPM
* worker : 멀티 프로세스, 멀티 스레드 MPM
>
>##### <?> worker
worker는 멀티 프로세스 + 멀티 스레드 MPM이다. 스레드는 메모리 공간을 공유하는 자식 프로세스를 생성하기 때문에 속도가 빨라지고 공간절약이 가능하다. 하지만 미스 매칭이 발생할 가능성이 있는 프로그램을 이용할 때는 적합하지 않다. worker는 스레드뿐 아니라 필요에 따라서 fork도 사용한다.

만약 PHP를 이용한다면 prefork MPM을 권장하고, Debian GNU/Linux에서는 PHP를 설치하면 자동으로 prefork 모듈을 설치한다. 이때 메모리 용량이 작은 서버에 일정 수준의 액세스 수가 존재하는 경우엔 worker의 멀티 스레드가 더 빠를 수 있다. 이때 ab(1)을 사용해서 조절할수있다.

##### <?> Listen 지시어
Listen 지시어는 기볹으로 IS에 마련되어 있는 모든 네트워크 인터페이스로 대기하지만, 포트 번호의 기본 값은 없다. **따라서 이 지시어가 없으면 httpd는 구동되지 않는다.** 또한 여러개의 포트를 지정할 수 있다.

##### <?> LoadModule 지시어
인수는 두가지가 있으며 첫번째는 모듈 이름으로, 모듈 안에 기술된 **모듈 식별자**를 지정한다. 두번째는 모듈의 PATH로, Serverroot로 지정한 PATH를 기준으로 상대 경로로 지정할 수도 있다. 새로 모듈을 추가하는 경우 도큐먼트에 LoadModule지시어로 지정해야 하는 파일명과 모듈 이름이 기술되어 있을 것이다.

##### <?> Include 지시어
지정한 PATH에 있는 설정 파일을 읽어들인다. 와일드 카드 기호를 사용할 수 있고 파일은 알파벳순으로 읽어들인다. 때문에 정수를 파일 앞에 붙이면 정리가 쉽다.

##### <?> 접근 제어
* deny,allow
1. 기본적으로 접근을 허가한다.
2. deny로 지정된 접근 리스트를 검사해 매치되면 거부한다.
3. allow로 지정된 접근 리스트를 검사해 매치되면 허가한다.

* allow,deny
1. 기본적으로 접근을 거부한다.
2. allow로 지정된 접근 리스트를 검사해 매치되면 허가한다.
3. deny로 지정된 접근 리스트를 검사해 매치되면 거부한다.

##### <?> DirectoryIndex 지시어
요청이 디렉터리 이름으로 되어 있을 때, 해당 디렉터리에 지정된 파일이 있으면 그 파일을 반환한다.

##### <?> `.htaccess`
분산 설정 파일이라고도 불리며 파일에 기술된 지시어의 내용은 해당 파일이 위치한 디렉터리와 그 서브 디렉터리에 모두 적용된다.

##### <?> Files 지시어
지정한 파일명에 지시어 설정 내용을 적용한다. 파일명은 와일드 카드 기호를 이용할 수 있으며, `~`를 넣으면 파일명에 정규 표현을 쓸 수 있다.

##### <?> MIME 타입
파일의 확장자로 데이터 형식을 판별할 수 있게 해주는 것이다. 이미지를 나타내는 image, 음성 파일을 나타내는 audio, 동영상 파일을 나타내는 퍙대 emddl dlTek.

> `.vnd` : 벤더에 따라 달라지는 파일형식이다. 보통은 RFC 등으로 규격화 되어 있으나, 제공 벤더에 따라 달라질 수 있다.

##### <?> HostnameLookups 지시어
로그 기술 시에 Off면 IP주소를, On이면 이름 분석 가능한 호스트는 FQDN을 기록한다. 이름분석에 시간이 오래 걸리는 시스템에선 큰 부하로 작용할 수 있으므로 로그 해석 시스템이 따로 있으면 역할을 분리하는게 더 좋다.

##### <?> AddDefaultCharset 지시어
text/plain 혹은 text/html MIME 타입 콘텐츠를 응답할때에 이용할 문자 코드를 지정한다. 만약 서버에 올린 콘텐츠의 문자가 깨지면 다음과 같은 순서로 확인한다.
1. 서버의 AddDefaultCharset 지시어가 설정되어 있는지 확인
2. 설정되었다면 콘텐츠와 같은 문자코드인지 확인
3. 코드가 다를경우 지시어 설정을 Off로 해주거나 주석처리
4. 이래도 해결되지 않으면 콘텐츠의 실제 문자 코드와 META 태그의 문자 코드 지정이 잘못되지 않았는지 확인한다.

##### <?> AddHandller 지시어
주어직 확장자를 어떻게 취급할 것인지 지정한다.

## 4. 설정 파일 - Debian
설정 파일은 `/etc/apache2`아래에 들어있으며 구동 스크립트 `/etc/init.d/apache2/`에서 `/etc/apache2/envvars`를 읽어와서 환경 변수로 삼아 실행한다. `/etc/apache2/apache2.conf` 안의 변수는 envvars를 참조한 것이다.

##### <?> event MPM
event MPM은 worker MPMㅇ을 바탕으로 한 것이지만 KeepAlive 요청 처리 스레드와 커넥션을 처리하는 스레드를 따로 생성해 효율화한 멀티 프로세싱 모듈이다.

##### <?> TypeConfig 지시어
따로 정의되어 있지 않으며, 별도파일에서 정의하고 있다.(`/etc/apache2/modes-available/mime.conf`)

##### <?> charset
charset은 AddDefaultCharset 지시어가 주석 처리된 상태로 기술된다. localized-error-pages는 다국어 지원 에러 페이지 설정이며 모두 주석처리되어 있으므로 직접 설정해주어야한다. other-vhosts-access-log는 CustomLog 지시어가 설정된 파일이다. (조건부 : sites-enabled 아래에 있는 각 virtualhost 파일에 기술이 없는 경우에 유효화하는 로그 설정)

##### <?> security
security에는 세개의 지시어가정의되어 있다.
* ServerTokens : 서버명, 버전 등의 정보를 반환할 것인지를 지정
* ServerSignature : 에러페이지 등에 서버 정보를 표시할 것인지를 지정
* TraceEnable : HTTP TRACE 메서드 온오프를 결정. HTTP TRACE는 웹 클라이언트의 요청이 그대로 클라이언트에 응답으로 돌아오기 때문에 Cookie나 pw등이 노출될 수 있어서 Off로 변경해 무효화하는것이 좋다.

> Debian GNU/Linux 에서는 모든 사이트를 가상 호스트로 정의한다.

# 4 > Postfix(SMTP 서버)
## 1. 메일 시스템의 개요
사용자가 메일을 발신할 때에는 MUA(Mail User Agent)를 사용하게 된다. 이는 MUA에서 MTA에 접속하여 메일을 발신하고 Mailbox에 접속하여 메일을 수신하는 애플리케이션으로, 메일 클라이언트라고도 부른다.

메일이 발신되면 여러 MTA를 거쳐서 상대 사용자가 메일을 받을 수 있는 MTA에 도착하고 메일함에 메일을 전달하게 된다.

목적 MTA에 도착하려면 DNS가 반드시 필요하다. MUA에서 메일 전송을 의뢰받은 MTA는 먼저 DNS에 목적 도메인의 메일 서버를 묻는다. DNS는 MX 레코드라는 리소스를 MTA에 반환하고 MTA는 MX레코드에 지시된 MTA로 메일 전송을 위한 통신을 시행한다.

MDA는 최종 목적지인 MTA에 도착한 메일을 사용자의 메일함에 배달하는 에이전트이다.

## 2. SMTP 서버 Postfix
##### <?> Postfix?
Postfix는 과거 대표적 오픈소스 MTA 였던 sendmail과의 이용 호환성을 유지하면서도 간편한 설정, 관리와 대용량 메일의 고속 전송을 구현한 MTA이다. sendmail은 설정이 아주 복잡했기 때문에 뒤쳐지게 되었고 사용자들은 다른 MTA로 넘어가게 되었다.

Postfix는 sendmail에 비해 메일 전송 시에 여러 개의 데몬이 협조하여 동작하기 때문에 동작을 파악하기 어려울 것같지만 설정 파일이 보기 쉽고 관리도 편하다.