# 1 > 인증
## 1. 인증이란?
주요 인증은 다음과 같다.
* 시스템에 로그인해 셸을 이용하기 위한 인증
* SMTP 서버에 메일을 전송하기 위한 인증
* POP3/IMAP4 등 메일을 사용하기 위한 인증
* 웹 애플리케이션을 이용하기 위한 인증
* 리눅스 시스템에서 실행하는 Windows 네트워크 공유 디렉터리에 접근하기 위한 인증

## 2. 리눅스 인증 순서
리눅스 시스템에 로그인하는 인증은 인증된 사용자가 본인만이 아는 인증정보를 시스템에 보내고 시스템이 가진정보와 비요하여 본인인지 확인한다. 확인되면 사용자에게 인증되었음을 통보한다.

이때 쓰이는 검증방법에는 여러가지가 있으며, UNIX 비밀번호, LDAP, Kerberos, NIS, SSL, SSH 공개키 인증 등을 인증 엔진으로 이용할 수 있다.

또한 사용자가 시스템에 인증 정보를 제공하는 방법으로는 생체인식, IC 카드나 USB 토큰 인증이 있다.

LDAP, Kerberos, NIS는 네트워크 경유로 사용자를 인증한다. 인증 서버에 인증 정보를 등록함으로써 직접 사용자 등록하지 않은 서버라도 인증 서버에서 로그인 정보를 가져올 수 있다. 로그인 등 서비스마다 이용하는 인증 모듈을 지정할 수 있는 서ㅂ스를 PAM(Pluggable Authentication Modules)이 제공한다. 단, PAM이 구동하는 로컬 시스템환경에서만 이용할 수 있다.

# 2 > PAM 인증
## 1. PAM?
PAM은 인증 실행을 위한 프레임워크로, 이용하는 프로그램에 인증방식지정이나 비밀번호 설정 강도 지정, 소속 그룹의 실행 허가 제어등의 기능을 제공한다. 이 설정 파일은 재부팅 없이 바로 적용된다.

현재는 다수의 리눅스 시스템에서 이와 같은 PAM을 이용한 중앙집중형 인증 시스템을 사용하고 있다. PAM은 나중에도 추가할 수 있는 모듈 아키텍쳐를 채택하고 있으므로 인증 방식을 유연하게 추가, 변경, 삭제할 수 있다.

PAM을 이용하려면 PAM 라이브러리를 링크해야한다. 특정 프로그램 인증이 PAM을 지원하는지는 ldd(1)로 PAM 라이브러리를 링크하고 있는지 확인하면 된다.

## 2. PAM 설정파일
`/etc/pam.d`에 있다. 이 디렉터리 아래에 PAM을 이용하는 애플리케이션이나 서비스별 설정 파일이 들어간다. 서비스별 설정파일은 `/etc/pam.d/서비스이름`으로 만들어진다. 이때 `/etc/pam.d` 아래 설정 파일을 하나의 `/etc/pam.conf`으로 관리할 수도 있지만, 서비스별로 나뉘어 있는 편이 관리가 더 쉽다.

> 만약 프로그램명을 가진 PAM 설정 파일이 없을 때에는 `/etc/pam.d/others`가 된다.

#### <!> `/etc/pam.d` 이하 : `[타입] [컨트롤 플래그] [모듈명] [모듈 인수]`
타입을 검증하여 가능/불가 여부를 결정하며, 컨트롤 플래그는 인증 성공/실패시의 동작을 지정한다.
또한 컨트롤 플래그는 [반환코드], [액션]과 조합하여 복수 지정하면 복잡한 컨트롤을 작성할 수 있다.
##### 타입은 다음과 같다.

| 타입 | 설명 |
|:--------:|:--------:|
| auth | 사용자 인증에 이용 |
| account | 유효기한이나 비밀번호 제한 등의 계정 제한에 이용 |
| password | 비밀번호 변경에 이용 |
| session | 사용자 인증 전후로 실행할 것을 지정함 |

##### 컨트롤 플래그는 다음과 같다.

| 컨트롤 플래그 | 설명 |
|:--------:|:--------:|
| required | 조건에 맞지 않으면 거부하지만,<br>사용자에게 거부를 통보하기 전에 서비스에 준비된 같은 [타입]을 시험해본다. |
| requisite | 조건에 맞지 않을 때에는 바로 거부한다. |
| sufficient | 조건을 통과하면 required/requisite의 조건 검증 결과를 알린다. |
| optional | 조건 검증은 되지만, 무시된다. |
| include | 지정된 `/etc/pam.d` 아래의 다른 파일을 포함한다. |
| substack | include와 동일하게 파일을 가져오지만, 컨트롤 플래그에 쓸 수 있는 done, die에 따라 동작이 달라진다. |

> include와 관련하여 Debian GNU/Linux 계열 배포판에서는 역사적인 경위로 @include를 이용하는 때가 있다. 이는 인수로 넘기는 파일명을 `/etc/pam.d`에서 찾아 가져오는 것과 같은 뜻이다.

##### 모듈명에는 이용하는 모듈을 지정한다. PAM 모듈은 `lib/security`와 `/lib64/security`를 찾는다.

| 모듈명 | 설명 |
|:--------:|:--------:|
| pam_unix | `/etc/passwd`, `/etc/shadow`에 의한 인증 |
| pam_selinux | SELinux의 시큐리티 컨텍스트를 참조함 |
| pam_env | `/etc/securyty/pam_env_conf`의 환경 변수 설정과 해제 |
| pam_deny | 거부함 |
| pam_permit | 허가함. 모든 타입에 이것을 지정하면 비밀번호 없이 무조건 로그인이 가능함 |
| pam_limits | 리소스 제한을 설정 |

모듈이나 모듈 인수의 사용법은 man 페이지가 있다.

#### <!> `/etc/pam.conf` : `[서비스] [타입] [컨트롤 플래그] [모듈명] [모듈 인수]`

# 3 > LDAP 인증
## 1. LDAP(LightweightDirectory Access Protocol)
LDAP은 디렉터리 서비스를 제공하는 프로토콜이다. LDAP 프로토콜 자체는 RFC 2251로서 LDAP v3이 정의되어 있으며, 이를 따른 제품이 여럿 존재한다.

LDAP은 참조와 검색이 많고 갱신이나 삭제가 그다지 빈번하지 않은 사용자 관리에 이용한다. 또한 복수 서비스 인증을 통합하는 싱글 사인 온 등에도 많이 사용하고 있다.

LDAP에 저장되는 모든것은 객체이며, 사용되는 트리 구조는 DIT(Directory Information Tree)이다. 클라이언트는 서버에 이 트리의 뿌리부터 목적 노드까지의 DN(Distinguished Name)을 지정함으로써 그 속성값을 얻는다.

## 2. OpenLDAP의 설정
#### 1. OpenLDAP의 실행에 필요한 것
* schema : 객체의 구성과 속성을 결정하는 데이터 구조, 투입하는 데이터는 모두 이 schema에 정의되어 있어야함. 읽지 않도록 설정할 수도 있음.
* 설정 파일 : OpenLDAP 2/3 이후부터는 cn=config라는 전용 DIT에 설정 항목을 저장함으로써 데몬 재구동 없이도 설정 변경을 적용하는 OLC(On-Line Configuration)을 채택하고 있다.

#### 2. LDIF
LDAP에는 LDIF(LDAP data interchange format)라는 디렉터리 정보를 추가, 갱신, 삭제하기 위한 텍스트 파일이 존재한다. slapd.conf가 이미 있을 때에는 이것을 변환해 설정한다.

> cn=config는 OpenLDAP의 DIT에 저장되는데, `/etc/opendap/slapd.d/cn=conf`에 LDIF 형식으로도 관리된다.

#### 3. 디버깅 방법
slapd(8)의 로그는 syslog를 이용하여 기록된다. 기본으로는 syslog(8)의 LOCAL4 facility를 이용한다. 구동 중인 syslog 실장 설정 파일을 참조하여 LOCAL4 facility로 기록할 파일을 지정한다. 예를 들어 rsyslog(8)인 경우에는 `/etc/rsuslog.conf`끝에 다음과 같이 추가 기술합니다.
```
local4.* /var/log/ldap.log
```

이로써 LOCAL4 facility 전체의 로그 레벨이 `/var/log/ldap.log`에 기록된다. 기본 로그 레벨은 stats로 되어 있으며, slapd로의 접속, 쿼리 결과를 기록한다. slapd 로그 레벨 항목은 책을 참고하자.

수집하려는 로그 레벨의 각 항목 정수 값, 15진수 또는 워드를 더해서 지정한다. 설정 파일이나 엔트리 확인 시에는 로그 레벨을 지정하여 디버그를 실시하지만, 구동 중인 상태라면 256/0x100/stats로 해 두는 것이 좋다.

# 4 > SSH 공개키 인증
## 1. 공개키 암호
공개키 암호라는 것은 비밀키와 공개키를 생성해 공개키는 배포하고, 비밀키는 사용자가 안전하게 지키는 방식이다. 두 키는 동시에 만들어지며, 한쪽에서 다른 한쪽을 생성하는 것은 불가능하다. 키는 DSA, RSA, ECDSA 등의 알고리즘을 이용해 생성된다.

#### 공개키와 비밀키의 차이

| 종류 | 차이점 |
|:--------:|:--------:|
| 공개키 | 일반에 공개<br>소유자 이외의 송신자가 암호화에 이용<br>소유자 이외의 수신자가 서명 검증에 이용<br>SSH에서 로그인하는 호스트에 등록하여 이용 |
| 비밀키 | 소유자가 가짐<br>공개키로 암호화된 메시지를 비밀키로 복호화<br>작성한 메시지에 대한 서명에 이용<br>SSH 커맨드 실행 시 비밀키를 지정함으로써, 공개키를 등록한 호스트의 로그인에 이용 |

#### SSH 서버의 공개키
SSH 서버는 자신의 호스트용 공개키와 비밀키를 갖고 있다. SSH 클라이언트는 서버의 공개키를 등록해둠으로써 해당 서버가 정말 목적 서버인지 판단할 수 있다.

만약 서버의 공개키와 서버에서 보내온 공개키가 다르면 다음과 같은 이유때문일 수 있다.
1. SSH 서버의 재 설치나 교체 등으로 말미암아 호스트 키가 변경되었다.
2. SSH 서버와 SSH 클라이언트 간에 제삼자가 끼어들었다.

2의 경우 통신내용은 제삼자에게 복호되어 도청될 가능성이 높다.(Man in the middle 공격) 때문에 침입 가능성이 있는 채로 SSH 서버에 로그인하는 것은 위험하며 SSH 서버가 이용하는 공개키를 확실하게 알아두어야 한다.

이때, SSH에서 로그인하는 사용자가 접속했을 때 표시되는 공개키의 fingerprint를 확인하는 방법으로 예방할 수 있다.

SSH로 처음 접속하면 fingerprint가 올바른 경우 "Are you sure you want to continue connecting(yes/no)?"라는 질문에 yes를 입력하면 `~/.ssh/known_hosts`에 공개키가 등록된다.

반면 이미 `~/.ssh/known_hosts`에 등록되어 있으나, 다시 SSH로 접속했을 때 호스트 키가 다른 경우에는 @WARNING이 표시된다. 이 메시지가 표시되는 한 로그인하려는 호스트에는 SSH 로그인이 불가능하다.

## 2. SSH의 공개키 인증
SSH의 공개키 인증은 해체 불가능한 비밀키와 공개키 한 쌍의 신뢰성을 바탕으로 성립되어 있다. 사용자는 로그인하려는 호스트에 자신의 공개키를 저장하고, 공개키 저장 수단은 호스트에 따라 달라진다.

##### 공개키 유효화
SSH 공개키 인증이 아직 등록되어 있지 않았을 때는 ssh-copy-id(1)을 사용하거나 scp(1)등을 사용해 공개키를 전송한다.

하지만 ssh-copy-id(1)은 원격 호스트에 로그인할 수 있는 상태가 아니면 등록이 불가능하다. 원격 호스트가 비밀번호 인증을 허가하고 있거나 또는 이미 공개키가 하나 이상 등록되어 있고 SSH에 로그인 가능한 상태여야 한다는 조건이 있기 때문이다.

이 경우에는 원격 호스트의 관리자에 공개키를 넘겨 등록을 부탁하면 된다.

##### SSH 서버에서의 공개키 설정
SSH 로그인을 받아들이는 쪽에서는 SSH 데몬의 설정을 변경함으로써 공개키 인증을 유효화하게 된다. `/etc/ssh/sshd_config`를 변경한 후 sshd를 재구동 하면 유효화 된다.

공개키 또는 비밀번호로 로그인한 것인지는 로그를 통해서 알 수 있다. Red Hat 계열은 `/var/log/secure`에, Debian 계열은 `/var/log/auth.log`에 기록되어 있다.

##### SSH 클라이언트의 디버그
SSH 클라이언트에서 디버그하려면 -v(verbose)를 붙여 실행하면 된다. v를 3개까지 붙여 디버그 레벨을 조절할 수 있다.